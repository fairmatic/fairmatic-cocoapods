#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
#ifndef FAIRMATICSDK_SWIFT_H
#define FAIRMATICSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wnon-modular-include-in-framework-module"
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#pragma clang diagnostic pop
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="FairmaticSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)
@class NSString;
@class FairmaticDriverAttributes;

/// This class contains parameters required by <code>Fairmatic</code> during setup.
SWIFT_CLASS_NAMED("Configuration")
@interface FairmaticConfiguration : NSObject
/// Your SDK key.
/// Pass in the SDK key for your app.
/// This field is REQUIRED and should be a valid string.
/// <code>nil</code> strings are not allowed.
/// Passing invalid string would cause SDK setup to fail.
@property (nonatomic, copy) NSString * _Nonnull sdkKey;
/// Unique ID for the current user. This can be any ID used by your app to
/// identify its users. This field is REQUIRED and should be a valid string.
/// Passing invalid string would cause SDK setup to fail.
/// The <code>driverId</code> must adhere to the following rules:
/// <ul>
///   <li>
///     Should not be an empty string.
///   </li>
///   <li>
///     Should be less than or equal to 50 characters.
///   </li>
///   <li>
///     Should not contain any of the following characters:  “?”, “ “, “&”, “/”, “", “;”, “#”, “\n”.
///   </li>
///   <li>
///     Should not contain non-UTF characters.
///   </li>
/// </ul>
@property (nonatomic, copy) NSString * _Nonnull driverId;
/// Attributes for the current user. These attributes are stored on the server
/// and are provided in Fairmatic’s APIs.
/// Use this param to provide meta-information about the user like name,
/// email, phone number.
@property (nonatomic, strong) FairmaticDriverAttributes * _Nonnull driverAttributes;
/// Creates a Fairmatic <code>Configuration</code> object.
/// \param sdkKey The SDK key to be used to initialize the SDK. Refer <code>sdkKey</code> for more details
///
/// \param driverId The driver identifer. Refer <code>driverId</code> for more details.
///
/// \param driverAttributes The additional attributes for the driver.
///
- (nonnull instancetype)initWithSdkKey:(NSString * _Nonnull)sdkKey driverId:(NSString * _Nonnull)driverId driverAttributes:(FairmaticDriverAttributes * _Nonnull)driverAttributes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end







/// Additional attributes of a <code>Fairmatic</code> driver.
SWIFT_CLASS_NAMED("DriverAttributes")
@interface FairmaticDriverAttributes : NSObject
/// Creates a <code>DriverAttributes</code> object with the given driver details
/// \param firstName The first name of the driver. This field is REQUIRED and should be a non-empty string which has less equal to
/// 50 characters. If you pass an empty string, the <code>Fairmatic/setupWith(configuration:completionHandler:)</code> API will report
/// <code>FairmaticError/invalidDriverName</code> error.
///
/// \param lastName The last name of the driver. This field is REQUIRED and should be a non-empty string which has less equal to
/// 50 characters. If you pass an empty string, the <code>Fairmatic/setupWith(configuration:completionHandler:)</code> API will report
/// <code>FairmaticError/invalidDriverName</code> error.
///
/// \param email The email of the driver
///
/// \param phoneNumber The phone number of the driver
///
- (nonnull instancetype)initWithFirstName:(NSString * _Nonnull)firstName lastName:(NSString * _Nonnull)lastName email:(NSString * _Nullable)email phoneNumber:(NSString * _Nullable)phoneNumber OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@class FairmaticSettings;
enum FairmaticSDKHealthReason : NSInteger;

/// The Fairmatic API. This class contains static methods for all the functionality that the Fairmatic SDK provides.
/// The client code should use this class to interact with the Fairmatic SDK.
/// <blockquote>
/// For all the methods that accept a completion handler as a parameter, please note that the completion handler is always invoked
/// on the main queue by the Fairmatic SDK. If you are performing heavy operations in the body of the completion handler, make sure
/// that you switch to the appropriate queue.
///
/// </blockquote>
/// <blockquote>
/// Warning: Make sure to call the <code>setupWith(configuration:completionHandler:)</code> method to set the SDK up before calling any other methods of the SDK.
///
/// </blockquote>
SWIFT_CLASS_NAMED("Fairmatic") SWIFT_AVAILABILITY(ios,introduced=13.0)
@interface Fairmatic : NSObject
/// No initialization needed from the client
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Initializes the Fairmatic SDK to automatically detect driving and collect
/// data. Client code should call this method before anything else in the Fairmatic API.
/// This method requires network connection to validate the sdkKey from the server.
/// Setup fails and the completion handler gets called with <code>false</code> if network is not available.
/// The completion handler gets called with <code>false</code> whenever setup fails and sets up the error with the
/// error code, cause and description.
/// Things to Consider:-
/// <ul>
///   <li>
///     This API should should be called in your <code>AppDelegate</code>‘s <code>application(_:didFinishLaunchingWithOptions:)</code> method as early
///     as possible.
///     When data collection needs to be stopped call the <code>teardown(completionHandler:)</code> method.
///     This might be done for example when the application’s user has logged out (and possibly a different user might login later).
///   </li>
/// </ul>
/// \param configuration The configuration object used to setup the Fairmatic SDK.
///
/// \param handler This block is called when fairmatic setup completes.
/// The application is expected to use the success and error
/// params passed to this block to handle failures. The handler
/// would be invoked on the main thread.
///
+ (void)setupWithConfiguration:(FairmaticConfiguration * _Nonnull)configuration completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))handler;
/// Stops driving data collection. The application can disable the Fairmatic SDK
/// by invoking this method. This method is asynchronous.
/// The teardown method is internally synchronized with
/// <code>setupWith(configuration:completionHandler:)</code> method, and the enclosing application should avoid synchronizing the two methods independently. Calling this with nil completion handler is same as calling teardown method.
/// \param handler Called when method completes. The handler would be invoked on main thread. Can be nil.
///
+ (void)teardownWithCompletionHandler:(void (^ _Nullable)(void))handler;
/// Wipe out all the data that Fairmatic keeps locally on the device.
/// When Fairmatic SDK is torn down, trip data that is locally persisted continues to remain persisted.
/// The data will be uploaded when SDK setup is called at a later time.
/// Wipeout should be used when the application wants to remove all traces of Fairmatic on the device.
/// Data cannot be recovered after this call.
/// <blockquote>
/// This call can only be made when the SDK is not running.
/// Call <code>teardown(completionHandler:)</code> to tear down a live SDK before making this call else <code>FairmaticError/notTornDown</code>
/// will be reported
///
/// </blockquote>
+ (void)wipeOutWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Returns an identifier which can be used to identify this SDK build.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull buildVersion;)
+ (NSString * _Nonnull)buildVersion SWIFT_WARN_UNUSED_RESULT;
/// Get the current settings of the SDK. The settings are returned in the completion handler.
/// This <code>Settings</code> class surfaces errors in the device or application settings that affect trip detection in the SDK.
/// Your application should check this object to ensure that the SDK is set up correctly and has all the necessary permissions
/// to detect trips accurately.
/// \param completionHandler A completion to be executed with the current settings of the SDK. This is a
/// <code>Settings</code> object that gives out information on the errors. The <code>completionHandler</code> is called on main thread, so if you want
/// to do any heavy processing, you should dispatch it to a background queue.
///
+ (void)getSettingsWithCompletionHandler:(void (^ _Nonnull)(FairmaticSettings * _Nonnull))completionHandler;
/// Logs all the critical permissions required by the SDK
/// \param reason Indicates the reason for logging SDK Health
///
/// \param completionHandler The completion handler to be called when the operation completes.
///
+ (void)logSDKHealth:(enum FairmaticSDKHealthReason)reason completionHandler:(void (^ _Nonnull)(NSError * _Nullable))completionHandler;
@end



@interface Fairmatic (SWIFT_EXTENSION(FairmaticSDK))
/// Start Fairmatic insurance period 1 in the SDK.
/// A manual trip of trackingId will be started immediately on this call.
/// If period 1 is already in progress with the same trackingId, this call will be a no-op.
/// \param trackingId An identifier which allows identifying this drive uniquely. This drive identifier must be unique for the user
///
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// A boolean that suggests successful completion of the call
/// and a valid <code>FairmaticError</code> is returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError/notSetup</code>, <code>FairmaticError/insurancePeriodSame</code>,
/// <code>FairmaticError/invalidTrackingId</code>.
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)startDriveWithPeriod1:(NSString * _Nonnull)trackingId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Start Fairmatic insurance period 2 in the SDK.
/// A manual trip of id trackingId will be started immediately on this call.
/// If period 2 is already in progress with the same trackingId, this call will be a no-op.
/// \param trackingId An identifier which allows identifying this drive uniquely.
/// This drive identifier must be unique for the user.
///
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// A boolean that suggests successful completion of the call
/// and a valid <code>FairmaticError</code> is returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError/notSetup</code>, <code>FairmaticError/insurancePeriodSame</code>,
/// <code>FairmaticError/invalidTrackingId</code>.
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)startDriveWithPeriod2:(NSString * _Nonnull)trackingId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Start Fairmatic insurance period 3 in the SDK.
/// A manual trip of id trackingId will be started immediately on this call.
/// If period 3 is already in progress with the same trackingId, this call will be a no-op.
/// \param trackingId An identifier which allows identifying this drive uniquely.
/// This drive identifier must be unique for the user.
///
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// A boolean that suggests successful completion of the call
/// and a valid error <code>FairmaticError</code> is returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError/notSetup</code>, <code>FairmaticError/insurancePeriodSame</code>,
/// <code>FairmaticError/invalidTrackingId</code>.
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)startDriveWithPeriod3:(NSString * _Nonnull)trackingId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Stop currently ongoing Fairmatic insurance period if any.
/// Ongoing trips at the time of this call will be stopped.
/// Auto trip detection is turned off on this call.
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// A boolean that suggests successful completion of the call
/// and a valid <code>FairmaticError</code> is returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError/notSetup</code>.
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)stopPeriod:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
@end

/// Error returned as code of <code>NSError</code> from <code>Fairmatic</code> public APIs in case of
/// failures.
/// In case you are using Objective-C, the errors would be returned as <code>NSError</code> objects. In that case, you can use the <code>code</code> of
/// the <code>NSError</code> to get the appropriate <code>FairmaticError</code>
/// \code
/// // Considering that the name of the variable is `nsError`,
/// // you can check the proper error code
/// // using the following format:
/// long code = (long) nsError.code
/// NSString *errorDescription = nsError.localizedDescription
/// NSLog(errorDescription)
///
/// if (errorCode == FairmaticErrorNotSetup) {
///     NSLog(@"Fairmatic SDK is not setup");
/// }
///
/// \endcodeYou can also cast the <code>code</code> of the error to <code>FairmaticError</code> enum to get the enum value like:
/// \code
/// FairmaticError errorCode = (FairmaticError) nsError.code
/// switch (fmError) {
///     case FairmaticErrorNotSetup:
///         NSLog(@"Fairmatic SDK is not setup");
///         break;
///     default:
///         break;
/// }
///
/// \endcode
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticError, "FairmaticError", open) {
/// SDK Key used in setup is invalid
  FairmaticErrorInvalidSDKKeyString = 0,
/// Network not reachable, Fairmatic.setup sometimes needs network call
/// for authentication and to update SDK configuration to work. This error
/// is returned whenever network is not available in these scenarios.
  FairmaticErrorNetworkUnreachable = 1,
/// Fairmatic SDK does not support the OS version of the device.
  FairmaticErrorUnsupportedOSVersion = 2,
/// Fairmatic SDK does not support the device type.
  FairmaticErrorDeviceUnsupported = 3,
/// Invalid string was passed as the <code>driverId</code> in the <code>Configuration</code>for the
/// <code>Fairmatic/setupWith(configuration:completionHandler:)</code> API.
/// The <code>driverId</code> passed to the above API must adhere to the following rules:
/// <ul>
///   <li>
///     Should not be an empty string.
///   </li>
///   <li>
///     Should be less than or equal to 50 characters.
///   </li>
///   <li>
///     Should not contain any of the following characters:  “?”, “ “, “&”, “/”, “", “;”, “#”, “\n”.
///   </li>
///   <li>
///     Should not contain non-UTF characters.
///   </li>
/// </ul>
  FairmaticErrorInvalidDriverId = 101,
/// Internal error.
  FairmaticErrorInternalFailure = 102,
/// Fairmatic SDK is not setup. This error is also returned in case SDK setup has started but completion handler for setup is
/// not called yet.
  FairmaticErrorNotSetup = 103,
/// Insurance Period hasn’t changed from the previously active period, action ignored.
/// This error may be returned from <code>Fairmatic/startDriveWithPeriod1(_:completionHandler:)</code>,
/// <code>Fairmatic/startDriveWithPeriod2(_:completionHandler:)</code>,
/// <code>Fairmatic/startDriveWithPeriod3(_:completionHandler:)</code>.
  FairmaticErrorInsurancePeriodSame = 104,
/// Invalid <code>trackingId</code> passed for new drive. This error may be returned from
/// <code>Fairmatic/startDriveWithPeriod1(_:completionHandler:)</code>
/// <code>Fairmatic/startDriveWithPeriod2(_:completionHandler:)</code>,
/// <code>Fairmatic/startDriveWithPeriod3(_:completionHandler:)</code>.
/// The <code>trackingId</code> passed to the above APIs must adhere to the following rules:
/// <ul>
///   <li>
///     Should not be an empty string.
///   </li>
///   <li>
///     Should be less than or equal to 50 characters.
///   </li>
///   <li>
///     Should not contain any of the following characters:  “?”, “ “, “&”, “/”, “", “;”, “#”, “\n”.
///   </li>
///   <li>
///     Should not contain non-UTF characters.
///   </li>
/// </ul>
  FairmaticErrorInvalidTrackingId = 105,
/// Fairmatic SDK is not torn down. This error is returned if the requested operation cannot
/// be completed while the SDK is running like the <code>Fairmatic/wipeOut(completion:)</code> API.
  FairmaticErrorNotTornDown = 106,
/// Some IO error occured while doing the operation. Refer to error description for more info.
  FairmaticErrorIoError = 107,
/// User is not authorized to use this application.
  FairmaticErrorUserDeprovisioned = 111,
/// This error is thrown when the size of the fleet has exceeded the limit. Please get in touch with your contact at Fairmatic
/// to increase the limit.
  FairmaticErrorFleetSizeLimitExceeded = 1002,
/// This error is thrown by the <code>Fairmatic/setupWith(configuration:completionHandler:)</code> API when the driver associated with
/// the provided <code>Configuration/driverId</code> has been deleted. Please get in touch with your contact at Fairmatic with the
/// <code>driverId</code>.
  FairmaticErrorDriverDeleted = 1003,
/// This error is thrown by the <code>Fairmatic/setupWith(configuration:completionHandler:)</code> API when you provide the driver name
/// provided in <code>DriverAttributes</code> is invalid.
/// Both the <code>firstName</code> and the <code>lastName</code> passed when initializing
/// <code>DriverAttributes/init(firstName:lastName:email:phoneNumber:)</code> must adhere to the following rules:
/// <ul>
///   <li>
///     Should not be empty.
///   </li>
///   <li>
///     Should be less than or equal to 50 characters.
///   </li>
/// </ul>
  FairmaticErrorInvalidDriverName = 1004,
/// This error is thrown by the <code>Fairmatic/setupWith(configuration:completionHandler:)</code> API when a setup call is already in
/// progress when the method was called`.
  FairmaticErrorSetupAlreadyInProgress = 1005,
/// This error is thrown by the <code>Fairmatic/setupWith(configuration:completionHandler:)</code> API when the account is not
/// provisioned in the Fairmatic system. Pleae contact Fairmatic support team with your SDK key.
  FairmaticErrorAccountNotProvisioned = 1006,
};
static NSString * _Nonnull const FairmaticErrorDomain = @"FairmaticSDK.FairmaticError";

/// The types of insurance period in <code>Fairmatic</code>
/// Each drive belongs to exactly one of these insurance periods.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticInsurancePeriod, "InsurancePeriod", open) {
/// Drives undertaken with insurance period 1 will have this value.
/// Refer: <code>Fairmatic/startDriveWithPeriod1(_:completionHandler:)</code>
  FairmaticInsurancePeriodPeriod1 = 0,
/// Drives undertaken with insurance period 2 will have this value.
/// Refer: <code>Fairmatic/startDriveWithPeriod2(_:completionHandler:)</code>
  FairmaticInsurancePeriodPeriod2 = 1,
/// Drives undertaken with insurance period 3 will have this value.
/// Refer: <code>Fairmatic/startDriveWithPeriod3(_:completionHandler:)</code>
  FairmaticInsurancePeriodPeriod3 = 2,
};







/// Dictates the reason for is logging SDK Health
/// The SDK health will be recorded when there is any update in permission from last recorded SDK health.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticSDKHealthReason, "SDKHealthReason", open) {
/// Indicates the reason is unknown.
/// This is the default value.
  FairmaticSDKHealthReasonUnknown = 0,
/// Indicates that the SDK health will be recorded due to silent push notification
  FairmaticSDKHealthReasonSilentPushNotification = 1,
/// Indicates that the SDK health will be recorded due to background processing
  FairmaticSDKHealthReasonBackgroundProcessing = 2,
};

@class FairmaticSettingsError;

/// This class surfaces errors in device or application settings that affects trip detection in the SDK.
SWIFT_CLASS_NAMED("Settings")
@interface FairmaticSettings : NSObject
/// List of errors that must be resolved for trip detection to work correctly.
@property (nonatomic, readonly, copy) NSArray<FairmaticSettingsError *> * _Nonnull errors;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


enum FairmaticSettingsErrorType : NSInteger;

/// This class represent an error in device or application settings that is affecting
/// the ability of the SDK to detect trips.
SWIFT_CLASS_NAMED("SettingsError")
@interface FairmaticSettingsError : NSObject
/// Error type for SettingsError
@property (nonatomic, readonly) enum FairmaticSettingsErrorType errorType;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// Error type for <code>SettingsError</code>
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticSettingsErrorType, "SettingsErrorType", open) {
/// The location authorization status is determined but the user hasn’t granted
/// the <em>Always</em> location authorization to the application.
  FairmaticSettingsErrorTypeLocationPermissionNotAuthorized = 0,
/// The activity authorization status is determined but the user has <em>not authorized</em> application to
/// access the motion and fitness data. This error will only be thrown if activity based trip detection
/// is enabled for the application.
  FairmaticSettingsErrorTypeActivityPermissionNotAuthorized = 1,
/// The location authorization is <em>Always</em> but location accuracy authorization
/// is <em>not</em> <code>CLAccuracyAuthorizationFullAccuracy</code>.
  FairmaticSettingsErrorTypeLocationAccuracyAuthorizationReduced = 2,
/// The location service is turned off.
  FairmaticSettingsErrorTypeLocationServiceOff = 3,
};



#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
