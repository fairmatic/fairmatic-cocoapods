#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
#ifndef FAIRMATICSDK_SWIFT_H
#define FAIRMATICSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreLocation;
@import Foundation;
@import ObjectiveC;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="FairmaticSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)
/// Confidence measure of the detected accident.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticAccidentConfidence, "AccidentConfidence", open) {
/// Accident was detected with a high confidence. The application might inform
/// emergency services directly after waiting for some time for user feedback.
  FairmaticAccidentConfidenceHigh = 0,
/// Accident was detected, but with a low confidence. The application might ask
/// the user for feedback before notifying any emergency services.
  FairmaticAccidentConfidenceLow = 1,
/// Confidence of an invalidating callback. This might be sent only when the application has opted into multiple accident callbacks
  FairmaticAccidentConfidenceInvalid = 2,
};

@class NSString;
@class FairmaticLocationPoint;
enum FairmaticVehicleType : NSInteger;
enum FairmaticCollisionSeverity : NSInteger;
enum FairmaticDirectionOfImpact : NSInteger;

/// Wrapper for meta-information related to an accident detected by the SDK.
SWIFT_CLASS_NAMED("AccidentInfo")
@interface FairmaticAccidentInfo : NSObject
/// The unique Id of drive during which the accident occured
@property (nonatomic, readonly, copy) NSString * _Nonnull driveId;
/// The location of the accident.
@property (nonatomic, readonly, strong) FairmaticLocationPoint * _Nonnull accidentLocation;
/// The timestamp of the accident in milliseconds since epoch.
@property (nonatomic, readonly) int64_t timestamp;
/// The session that was in progress when the accident occured, if a session
/// was started in the SDK.
/// See <code>Fairmatic/startSession(_:)</code>
@property (nonatomic, readonly, copy) NSString * _Nullable sessionId;
/// The tracking id of the ongoing drive when the accident occured.
/// <ul>
///   <li>
///     See: <code>Fairmatic/startManualDrive(trackingId:completionHandler:)</code>
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSString * _Nullable trackingId;
/// The confidence of detected accident.
@property (nonatomic, readonly) enum FairmaticAccidentConfidence confidence;
/// Measures an approximate precision of the detected collision. Ranges between 0 to 100.
/// Note: A confidence number of 0 indicated that it was <em>not</em> an accident.
/// 0 confidence number can be sent as a part of potential accident callback
/// to invalidate the previous callback final accident callback for the same accident.
/// 0 confidence number will never come as a part of potential accident callback.
/// Checkout <code>MockAccidentConfig/invalidateFinalCallback()</code> to test this scenario during development.
@property (nonatomic, readonly) NSInteger confidenceNumber;
/// A unique identifier of this accident.
@property (nonatomic, readonly, copy) NSString * _Nonnull accidentId;
/// Vehicle type detected by SDK at the time of the accident.
/// Default value is <code>VehicleType/car</code>.
@property (nonatomic, readonly) enum FairmaticVehicleType vehicleType;
/// This field specifies the collision severity at the time of potential accident callback and final accident callback.
/// Default value is <code>CollisionSeverity/unknown</code>.
@property (nonatomic, readonly) enum FairmaticCollisionSeverity collisionSeverity;
/// This field specifies the direction of impact at the time of potential accident callback and final accident callback.
/// Default value is <code>DirectionOfImpact/unknown</code>.
@property (nonatomic, readonly) enum FairmaticDirectionOfImpact directionOfImpact;
/// Returns a dictionary that represents the <code>AccidentInfo</code> object.
- (NSDictionary * _Nonnull)toDictionary SWIFT_WARN_UNUSED_RESULT;
/// Returns a JSON formatted string that represents the <code>AccidentInfo</code> object.
- (NSString * _Nonnull)toJson SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum FairmaticInsurancePeriod : NSInteger;

/// Information about the active drive if any.
SWIFT_CLASS_NAMED("ActiveDriveInfo")
@interface FairmaticActiveDriveInfo : NSObject
/// The unique Id for this drive
@property (nonatomic, readonly, copy) NSString * _Nonnull driveId;
/// The start timestamp of trip in milliseconds since epoch.
@property (nonatomic, readonly) int64_t startTimestamp;
/// The insurance period for this drive
@property (nonatomic, readonly) enum FairmaticInsurancePeriod insurancePeriod;
/// The current speed of vehicle in meters/second.
@property (nonatomic, readonly) double currentSpeed;
/// The distance covered so far in this trip in meters.
@property (nonatomic, readonly) double distance;
/// Tracking id is specified by the enclosing application when it
/// wants to start a drive manually by calling <code>Fairmatic/startManualDrive(trackingId:completionHandler:)</code>
/// This may be the case for example in a taxi cab application that would
/// know when to start a drive based on when a meter gets flagged. The <code>trackingId</code> will be <code>nil</code> in case of auto detected drives.
@property (nonatomic, readonly, copy) NSString * _Nullable trackingId;
/// Session id is specified by the enclosing application when it wants to
/// record a session using <code>Fairmatic/startSession(_:)</code>
/// <code>sessionId</code> will be <code>nil</code> if there is no session associated with that drive.
@property (nonatomic, readonly, copy) NSString * _Nullable sessionId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum FairmaticDriveType : NSInteger;
enum FairmaticUserMode : NSInteger;
@class FairmaticEvent;
enum FairmaticPhonePosition : NSInteger;
@class FairmaticTripWarning;
@class FairmaticExtrapolationDetails;

/// Wrapper for meta-information related to a drive.
SWIFT_CLASS_NAMED("DriveInfo")
@interface FairmaticDriveInfo : NSObject
/// The unique Id for this drive
@property (nonatomic, readonly, copy) NSString * _Nonnull driveId;
/// The type of the drive. This decides what other info parameters will be populated.
/// A drive callback will be sent even for falsely detected drives or for non
/// automobile trips (Eg. biking, public transport).
@property (nonatomic, readonly) enum FairmaticDriveType driveType;
/// Whether the user was a driver or a passenger.
/// Driver/Passenger detection is disabled by default. Reach out to your
/// contact at Fairmatic to enable this feature.
/// Only present when <code>driveType</code> is
/// <code>DriveType/drive</code> and the SDK was able to determine with confidence
/// whether the user was a driver or a passenger.
/// If the SDK was not able to determine the user mode, this field is
/// <code>UserMode/unavailable</code>.
/// <blockquote>
/// Driver/Passenger detection is disabled by default
///
/// </blockquote>
@property (nonatomic, readonly) enum FairmaticUserMode userMode;
/// The insurance period for this drive
@property (nonatomic, readonly) enum FairmaticInsurancePeriod insurancePeriod;
/// The start timestamp of trip in milliseconds since epoch.
@property (nonatomic, readonly) int64_t startTimestamp;
/// The end timestamp of trip in milliseconds since epoch
@property (nonatomic, readonly) int64_t endTimestamp;
/// The average speed of trip in meters/second
@property (nonatomic, readonly) double averageSpeed;
/// The maximum speed of trip in meters/second
/// If we do not receive any accurate location data during the drive, this
/// property would be set to -1
@property (nonatomic, readonly) double maxSpeed;
/// The distance of the trip in meters
@property (nonatomic, readonly) double distance;
/// A list of <code>LocationPoint</code> objects corresponding to this trip in
/// increasing order of timestamp. The first point corresponds to trip start location
/// and last to trip end location.
/// This is a sampled approximation of the drive which gives an indication of
/// the path taken by the driver. It is not the full detailed location data of the drive.
/// If no waypoints are recorded during the drive, this is an empty array.
@property (nonatomic, readonly, copy) NSArray<FairmaticLocationPoint *> * _Nonnull waypoints;
/// Tracking id is specified by the enclosing application when it
/// wants to start a drive manually by calling <code>Fairmatic/startManualDrive(trackingId:completionHandler:)</code>
/// This may be the case for example in a taxi cab application that would
/// know when to start a drive based on when a meter gets flagged. trackingId will be
/// nil in case of auto detected drives.
@property (nonatomic, readonly, copy) NSString * _Nullable trackingId;
/// Session id is specified by the enclosing application when it wants to
/// record a session using <code>Fairmatic/startSession(_:)</code>
/// sessionId will be nil if there is no session associated with that drive.
@property (nonatomic, readonly, copy) NSString * _Nullable sessionId;
/// A list of <code>Event</code> objects for this trip in increasing order of timestamp.
/// In case of no events in the trip an empty list is returned.
@property (nonatomic, readonly, copy) NSArray<FairmaticEvent *> * _Nonnull events;
/// The position of the phone during this trip.
@property (nonatomic, readonly) enum FairmaticPhonePosition phonePosition;
/// A list of <code>TripWarning</code> objects for this trip.
/// In case of no warnings in the trip an empty list is returned.
@property (nonatomic, readonly, copy) NSArray<FairmaticTripWarning *> * _Nonnull tripWarnings;
/// The type of vehicle.
/// If <code>driveType</code> is not <code>DriveType/drive</code> then it will be set to <code>VehicleType/unknown</code>.
/// NOTE: This value will only be populated in <code>FairmaticDelegate/processAnalysis(ofDrive:)</code> callback.
@property (nonatomic, readonly) enum FairmaticVehicleType vehicleType;
/// The extrapolated details for a drive.
/// If <code>driveType</code> is not <code>DriveType/drive</code> then it will be set to nil.
@property (nonatomic, readonly, strong) FairmaticExtrapolationDetails * _Nullable extrapolationDetails;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// This contains the fully analyzed results for a drive, this is returned from
/// <code>FairmaticDelegate/processAnalysis(ofDrive:)</code> callback for all the trips with the value of
/// <code>DriveInfo/driveType</code> not set to <code>DriveType/invalid</code>.
/// The data of this type will always be of equal or better quality than
/// <code>EstimatedDriveInfo</code> returned from <code>FairmaticDelegate/processEnd(ofDrive:)</code>
/// Typically <code>FairmaticDelegate/processAnalysis(ofDrive:)</code> will be fired within
/// a few seconds after <code>FairmaticDelegate/processEnd(ofDrive:)</code> callback but in some rare cases
/// this delay can be really large depending on phone network conditions.
/// The callback for this <code>FairmaticDelegate/processAnalysis(ofDrive:)</code> will be fired in trip
/// occurrence sequence, i.e. from oldest trip to the latest trip.
SWIFT_CLASS_NAMED("AnalyzedDriveInfo")
@interface FairmaticAnalyzedDriveInfo : FairmaticDriveInfo
@end

/// Collision severity of the detected accident.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticCollisionSeverity, "CollisionSeverity", open) {
/// Unknown severity collision.
  FairmaticCollisionSeverityUnknown = 0,
/// Low severity collision
  FairmaticCollisionSeverityLow = 1,
/// High severity collision.
  FairmaticCollisionSeverityHigh = 2,
};

@class FairmaticDriverAttributes;
enum FairmaticDriveDetectionMode : NSInteger;

/// This class contains parameters required by <code>Fairmatic</code> during setup.
SWIFT_CLASS_NAMED("Configuration")
@interface FairmaticConfiguration : NSObject
/// Your SDK key.
/// Pass in the SDK key for your app.
/// This field is REQUIRED and should be a valid string.
/// Check <code>Fairmatic/isValidInputParameter(_:)</code> to validate this field. <code>nil</code> strings are not allowed.
/// Passing invalid string would cause SDK setup to fail.
@property (nonatomic, copy) NSString * _Nonnull sdkKey;
/// Unique ID for the current user. This can be any ID used by your app to
/// identify its users.
/// Use <code>Fairmatic/isValidInputParameter(_:)</code> to verify that <code>driverId</code> is valid.
/// This field is REQUIRED and should be a valid string.
/// Passing invalid string would cause SDK setup to fail.
@property (nonatomic, copy) NSString * _Nonnull driverId;
/// Attributes for the current user. These attributes are stored on the server
/// and are provided in Fairmatic’s APIs. Any existing attributes would be overwritten
/// on the server when a non-nil value for this param is passed. Passing nil is a no-op.
/// Use this param to provide meta-information about the user like name,
/// email, phone number or any custom attributes you wish to provide.
@property (nonatomic, strong) FairmaticDriverAttributes * _Nonnull driverAttributes;
/// Use this mode to control the SDK’s behaviour for detecting drives
/// automatically. This mode can be changed at a later point using
/// <code>Fairmatic/setDriveDetectionMode(_:completionHandler:)</code> method.
/// Applications which do not want the SDK to continuously track drives in
/// background should set this value to <code>DriveDetectionMode/autoOFF</code>. With this, the application needs to call <code>Fairmatic/startManualDrive(trackingId:completionHandler:)</code> method to record drives. In case the application wants to enable auto drive detection only for a fixed duration (like when the driver is on-duty), use method <code>Fairmatic/setDriveDetectionMode(_:completionHandler:)</code>
/// to change the mode to <code>DriveDetectionMode/autoON</code> for that period and set it back to <code>DriveDetectionMode/autoOFF</code> (once the driver goes off-duty).
@property (nonatomic) enum FairmaticDriveDetectionMode driveDetectionMode;
/// Developers have to set this property to <code>true</code> if the app implements multiple accident callbacks -
/// potential callback and final callback.
/// If set to <code>false</code>, the SDK assumes that potential accident callback is not implemented.
/// The default value of this property is <code>false</code>.
@property (nonatomic) BOOL implementsMultipleAccidentCallbacks;
/// Creates a Fairmatic <code>Configuration</code> object.
/// \param sdkKey The SDK key to be used to initialize the SDK. Refer <code>sdkKey</code> for more details
///
/// \param driverId The driver identifer. Refer <code>driverId</code> for more details.
///
/// \param driverAttributes The additional attributes for the driver.
///
- (nonnull instancetype)initWithSdkKey:(NSString * _Nonnull)sdkKey driverId:(NSString * _Nonnull)driverId driverAttributes:(FairmaticDriverAttributes * _Nonnull)driverAttributes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Direction of impact detected by SDK at the time of the accident
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticDirectionOfImpact, "DirectionOfImpact", open) {
/// Indicates an unknown direction of impact
  FairmaticDirectionOfImpactUnknown = 0,
/// Indicates a front direction of impact
  FairmaticDirectionOfImpactFront = 1,
/// Indicates a rear direction of impact
  FairmaticDirectionOfImpactRear = 2,
/// Indicates a broadside direction of impact
  FairmaticDirectionOfImpactBroadside = 3,
};


/// Dictates the functioning of Fairmatic’s drive detection.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticDriveDetectionMode, "DriveDetectionMode", open) {
/// <code>Fairmatic</code> SDK will automatically track drives in background in
/// this mode once the SDK is setup. At the same time, the application can invoke
/// <code>Fairmatic/startManualDrive(trackingId:completionHandler:)</code> to explicitly start recording a drive.
  FairmaticDriveDetectionModeAutoON = 0,
/// In this mode auto drive-detection is disabled. All other APIs on <code>Fairmatic</code>
/// can be invoked independent of this mode. For recording trips in this mode, the
/// application has to explicitly invoke the <code>Fairmatic/startManualDrive(trackingId:completionHandler:)</code> method.
  FairmaticDriveDetectionModeAutoOFF = 1,
/// In this mode drive detection is controlled by Insurance period APIs present in
/// <code>Fairmatic</code> class. Only insurance related APIs should be used in this mode to control <code>FairmaticSDK</code> behavior.
/// This is the Default mode.
/// <blockquote>
/// This is the Default mode.
///
/// </blockquote>
/// <h2>See Also</h2>
/// <ul>
///   <li>
///     <code>Fairmatic/startDriveWithPeriod1(_:)</code>
///   </li>
///   <li>
///     <code>Fairmatic/startDriveWithPeriod2(_:completionHandler:)</code>
///   </li>
///   <li>
///     <code>Fairmatic/startDriveWithPeriod3(_:completionHandler:)</code>
///   </li>
///   <li>
///     <code>Fairmatic/stopPeriod(_:)</code>
///   </li>
/// </ul>
  FairmaticDriveDetectionModeInsurance = 2,
};



/// Information about a drive that was resumed in the <code>Fairmatic</code> SDK.
/// This is called after the drive recording resumes after a gap. The gap may occur due to
/// an application restart by the OS, application kill and restart by a user, an application crash
/// etc.
SWIFT_CLASS_NAMED("DriveResumeInfo")
@interface FairmaticDriveResumeInfo : NSObject
/// The unique Id for this drive
@property (nonatomic, readonly, copy) NSString * _Nonnull driveId;
/// The insurance period for this drive
@property (nonatomic, readonly) enum FairmaticInsurancePeriod insurancePeriod;
/// The start timestamp of trip in milliseconds since epoch.
@property (nonatomic, readonly) int64_t startTimestamp;
/// The distance of the trip in meters
@property (nonatomic, readonly) double distance;
/// A list of <code>LocationPoint</code> objects corresponding to this trip in
/// increasing order of timestamp. The first point corresponds to trip start location
/// and last to trip end location.
/// This is a sampled approximation of the drive which gives an indication of
/// the path taken by the driver. It is not the full detailed location data of the drive.
/// If no waypoints are recorded during the drive, this is an empty array.
@property (nonatomic, readonly, copy) NSArray<FairmaticLocationPoint *> * _Nonnull waypoints;
/// Tracking id is specified by the enclosing application when it
/// wants to start a drive manually by calling <code>Fairmatic/startManualDrive(trackingId:completionHandler:)</code>
/// This may be the case for example in a taxi cab application that would
/// know when to start a drive based on when a meter gets flagged. trackingId will be
/// <code>nil</code> in case of auto detected drives.
@property (nonatomic, readonly, copy) NSString * _Nullable trackingId;
/// Session id is specified by the enclosing application when it wants to
/// record a session using <code>Fairmatic/startSession(_:)</code>
/// sessionId will be <code>nil</code> if there is no session associated with that drive.
@property (nonatomic, readonly, copy) NSString * _Nullable sessionId;
/// The start timestamp of the gap in drive recording in milliseconds.
/// The drive was resumed after this gap.
@property (nonatomic, readonly) int64_t driveGapStartTimestampMillis;
/// The end timestamp of the gap in drive recording in milliseconds.
/// The drive was resumed after this gap.
@property (nonatomic, readonly) int64_t driveGapEndTimestampMillis;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Information about start of a drive.
SWIFT_CLASS_NAMED("DriveStartInfo")
@interface FairmaticDriveStartInfo : NSObject
/// The unique Id for this drive
@property (nonatomic, readonly, copy) NSString * _Nonnull driveId;
/// The start timestamp of trip in milliseconds since epoch
@property (nonatomic, readonly) int64_t startTimestamp;
/// The insurance period for this drive
@property (nonatomic, readonly) enum FairmaticInsurancePeriod insurancePeriod;
/// The distance of the trip in meters
@property (nonatomic, readonly) double distance;
/// A list of <code>LocationPoint</code> objects corresponding to this trip in
/// increasing order of timestamp. The first point corresponds to trip start location.
/// This array contains a series of <code>LocationPoint</code> which
/// approximate the path taken by the driver. This is not the detailed location
/// data but rather a sample representing route geometry.
/// note:
/// The array might be empty if no accurate gps location is determined till
/// <code>FairmaticDelegate.processStart(ofDrive:)</code> call.
@property (nonatomic, readonly, copy) NSArray<FairmaticLocationPoint *> * _Nullable waypoints;
/// Tracking id is specified by the enclosing application when it
/// wants to start a drive manually by calling <code>Fairmatic/startManualDrive(trackingId:completionHandler:)</code>
/// This may be the case for example in a taxi cab application that would
/// know when to start a drive based on when a meter gets flagged. trackingId will be
/// nil in case of auto detected drives.
@property (nonatomic, readonly, copy) NSString * _Nullable trackingId;
/// Session id is specified by the enclosing application when it wants to
/// record a session using <code>Fairmatic/startSession(_:)</code>
/// <code>sessionId</code> will be nil if there is no session associated with that drive.
@property (nonatomic, readonly, copy) NSString * _Nullable sessionId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// The type of the drive returned from <code>DriveInfo/driveType</code>.
/// This decides what other <code>DriveInfo</code> parameters will be populated.
/// A drive callback can be sent as a false alarm or when we detect that the user was not
/// actually driving but moved using other means of transport.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticDriveType, "DriveType", open) {
/// Sometimes, the SDK detects that a trip is invalid after it has been started.
/// In these cases, the values for <code>DriveInfo/waypoints</code>, <code>DriveInfo/events</code>,
/// <code>DriveInfo/maxSpeed</code> and <code>DriveInfo/averageSpeed</code>
/// will have invalid values.
  FairmaticDriveTypeInvalid = 0,
/// This was not a driving trip. For e.g bike and train rides will fall under this trip type.
/// The <code>DriveInfo</code> will have <code>DriveInfo/waypoints</code>, <code>DriveInfo/maxSpeed</code>,
/// <code>DriveInfo/averageSpeed</code>, and <code>DriveInfo/events</code>.
  FairmaticDriveTypeNonDriving = 1,
/// This trip was taken in a valid <code>VehicleType</code>.
/// If the SDK determined the user to be a driver or a passenger, the value
/// will be available in <code>DriveInfo/userMode</code>
/// The <code>DriveInfo</code> will have <code>DriveInfo/waypoints</code>, <code>DriveInfo/maxSpeed</code>,
/// <code>DriveInfo/averageSpeed</code>,  and <code>DriveInfo/events</code>
  FairmaticDriveTypeDrive = 2,
};


/// Additional attributes of a <code>Fairmatic</code> driver.
/// The application can specify both predefined and custom attributes for a driver.
/// These attributes are associated with a SDK <code>Configuration/driverId</code> at SDK initialization time.
/// In addition to predefined special attributes, up to 4 custom key value attributes
/// can be associated with a driver using the Fairmatic SDK.
/// <blockquote>
/// Warning: All attribute keys can be atmost 64 characters in length.
///
/// </blockquote>
/// <blockquote>
/// Warning: All attribute values can be atmost 1024 characters in length.
///
/// </blockquote>
/// <h2>See Also</h2>
/// <ul>
///   <li>
///     <code>DriverAttributes/setCustomAttribute(_:forKey:)</code>
///   </li>
/// </ul>
SWIFT_CLASS_NAMED("DriverAttributes")
@interface FairmaticDriverAttributes : NSObject
/// Creates a <code>DriverAttributes</code> object with the given driver details
/// \param name The name of the driver. This field is REQUIRED and should be a non-empty string.
/// If you pass an empty string, the <code>Fairmatic/setupWith(configuration:delegate:completionHandler:)</code> API will report <code>FairmaticError/invalidDriverName</code> error.
///
/// \param email The email of the driver
///
/// \param phoneNumber The phone number of the driver
///
- (nonnull instancetype)initWithName:(NSString * _Nonnull)name email:(NSString * _Nullable)email phoneNumber:(NSString * _Nullable)phoneNumber OBJC_DESIGNATED_INITIALIZER;
/// Set the custom attribute of the user.
/// Up to 4 custom attributes can be set for a user.
/// A new value for an existing key would be overwritten only if the value length
/// is within 1024 characters, otherwise the original value would be retained.
/// \param key A key for the custom attribute. The maximum key length is 64 characters.
///
/// \param value Value of the custom attribute. The maximum value length is 1024 characters.
///
///
/// returns:
/// <code>true</code>, if the value was set, <code>false</code> otherwise.
- (BOOL)setCustomAttribute:(NSString * _Nonnull)value forKey:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
/// Set the vehicle type for the driver.
/// To enable the feature for any vehicle type other than <code>VehicleType/car</code>,
/// please reach out to your contact at Fairmatic
/// \param vehicleType The <code>VehicleType</code> for the driver.
/// Passing <code>VehicleType/unknown</code> is a no-op.
///
///
/// returns:
/// <code>true</code>, if the value was set, <code>false</code> otherwise.
- (BOOL)setVehicleType:(enum FairmaticVehicleType)vehicleType SWIFT_WARN_UNUSED_RESULT;
/// Returns driver attributes as a json string. Empty string if json serialization
/// fails.
- (NSString * _Nonnull)asJson SWIFT_WARN_UNUSED_RESULT;
/// Returns the driver attributes as a dictionary.
- (NSDictionary * _Nonnull)asDictionary SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// This contains the best estimated results for a drive, this is returned from
/// <code>FairmaticDelegate/processEnd(ofDrive:)</code> callback.
/// The data of this type will always be of same or little bad quality than
/// <code>AnalyzedDriveInfo</code> returned from <code>FairmaticDelegate/processAnalysis(ofDrive:)</code>
/// All drives with driveType not set to <code>DriveType/invalid</code> will get a
/// corresponding <code>FairmaticDelegate/processAnalysis(ofDrive:)</code> callback.
/// Typically <code>FairmaticDelegate/processAnalysis(ofDrive:)</code> will be fired within
/// a few seconds after <code>FairmaticDelegate/processEnd(ofDrive:)</code> callback but in some rare cases
/// this delay can be really large depending on phone network conditions.
SWIFT_CLASS_NAMED("EstimatedDriveInfo")
@interface FairmaticEstimatedDriveInfo : FairmaticDriveInfo
@end

enum FairmaticventType : NSInteger;
enum FairmaticEventSeverity : NSInteger;
enum FairmaticTurnDirection : NSInteger;
@class FairmaticSpeedingData;

/// Represents a driving behavior event like phone use, aggressive acceleration etc.
/// It is part of <code>DriveInfo</code> object of <code>FairmaticDelegate/processEnd(ofDrive:)</code> callback.
SWIFT_CLASS_NAMED("Event")
@interface FairmaticEvent : NSObject
/// Start location of the event.
@property (nonatomic, readonly, strong) FairmaticLocationPoint * _Nonnull startLocation;
/// Stop location of the event.
@property (nonatomic, readonly, strong) FairmaticLocationPoint * _Nonnull stopLocation;
/// Epoch timestamp of the start of the event.
@property (nonatomic, readonly) int64_t startTime;
/// Epoch timestamp of the end of the event
@property (nonatomic, readonly) int64_t endTime;
/// The type of the event.
@property (nonatomic, readonly) enum FairmaticventType eventType;
/// The severity of the event.
@property (nonatomic, readonly) enum FairmaticEventSeverity eventSeverity;
/// Denotes the turn direction of a hard turn whether a left or right turn.
@property (nonatomic, readonly) enum FairmaticTurnDirection turnDirection;
/// Additional data in the <code>eventType</code> is <code>EventType/overSpeeding</code>, will be <code>nil</code> otherwise.
@property (nonatomic, readonly, strong) FairmaticSpeedingData * _Nullable speedingData;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// This is returned in <code>Event/eventSeverity</code>, it represents the severity of event if applicable for that event type.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticEventSeverity, "EventSeverity", open) {
/// Severity not applicable for this event type.
  FairmaticEventSeverityNone = 0,
/// This is a low severity event.
  FairmaticEventSeverityLow = 1,
/// This is a high severity event.
  FairmaticEventSeverityHigh = 2,
};

/// The event type as specified in <code>Event.eventType</code>
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticventType, "EventType", open) {
/// This denotes the aggressive behavior of braking too hard.
  FairmaticventTypeHardBrake = 0,
/// This denotes the aggressive behavior of accelerating too fast.
  FairmaticventTypeAggressiveAcceleration = 1,
/// This denotes the distracting behavior of handling the phone while driving.
  FairmaticventTypePhoneHandling = 2,
/// This denotes the aggressive behavior of speeding more than allowed.
/// You will also receive <code>Event/speedingData</code> in this case.
  FairmaticventTypeOverSpeeding = 3,
/// This denotes a collision as detected by Fairmatic SDK.
/// You will also receive <code>FairmaticDelegate/processAccidentDetected(_:)</code>
/// in realtime for this event.
  FairmaticventTypeAccident = 4,
/// This denotes a hard turn as detected by Fairmatic SDK.
  FairmaticventTypeHardTurn = 5,
/// This denotes the distracting behavior of interacting with the phone screen while driving.
  FairmaticventTypePhoneScreenInteraction = 6,
/// This denotes stop sign violations as detected by Fairmatic SDK.
  FairmaticventTypeStopSignViolation = 7,
/// This denotes the distracting behavior of being in a phone call, hands free.
  FairmaticventTypeHandsFreePhoneCall = 8,
/// This denotes the phone screen is on but user is not actively interacting with the screen.
  FairmaticventTypePassiveDistraction = 9,
};


/// Wrapper for extrapolated details for a drive.
SWIFT_CLASS_NAMED("ExtrapolationDetails")
@interface FairmaticExtrapolationDetails : NSObject
/// The additional distance that might be covered before the drive start is detected.
@property (nonatomic, readonly) double extrapolatedDistance;
/// The estimated start location of the active drive.
@property (nonatomic, readonly, strong) FairmaticLocationPoint * _Nonnull estimatedStartLocation;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@protocol FairmaticDelegate;
@class FairmaticSettings;
enum FairmaticSDKHealthReason : NSInteger;

/// The Fairmatic API. This class contains static methods for all the functionality that the Fairmatic SDK provides.
/// The client code should use this class to interact with the Fairmatic SDK.
/// <blockquote>
/// For all the methods that accept a completion handler as a parameter, please note that the completion handler is always invoked on the main queue by the Fairmatic SDK. If you are performing heavy operations in the body of the completion handler, make sure that you switch to the appropriate queue.
///
/// </blockquote>
/// <blockquote>
/// Warning: Make sure to call the <code>setupWith(configuration:delegate:completionHandler:)</code> method to set the SDK up with calling any other methods.
///
/// </blockquote>
SWIFT_CLASS_NAMED("Fairmatic") SWIFT_AVAILABILITY(ios,introduced=13.0)
@interface Fairmatic : NSObject
/// No initialization needed from the client
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Initializes the Fairmatic SDK to automatically detect driving and collect
/// data. Client code should call this method before anything else in the Fairmatic API.
/// This method requires network connection to validate the sdkKey from the server.
/// Setup fails and returns <code>false</code> if network is not available.
/// This method returns <code>false</code> whenever setup fails and sets up the error with the
/// error code, cause and description.
/// Things to Consider:-
/// <ul>
///   <li>
///     This API should should be called in your <code>AppDelegate</code>’s <code>application(_:didFinishLaunchingWithOptions:)</code> method as early as possible.
///   </li>
///   <li>
///     If <code>Configuration/driverId</code> or <code>Configuration/sdkKey</code> is changed while
///     doing multiple setups, it will be the same as calling <code>Fairmatic/teardown(completionHandler:)</code> followed by calling <code>Fairmatic/setupWith(configuration:delegate:completionHandler:)</code> with the
///     new parameters.
///   </li>
/// </ul>
/// When data collection needs to be stopped call the <code>teardown(completionHandler:)</code> method.
/// This might be done for example when the application’s user has logged out (and possibly a different user might login later).
/// \param configuration The configuration object used to setup the SDK. This
/// object contains your credentials along with
/// additional setup parameters that you can use to provide
/// meta-information about the user or to tune the sdk
/// functionality.
///
/// \param delegate The delegate object on which Fairmatic SDK will issue callbacks for
/// handling various events. Can be <code>nil</code> if you do not want to
/// register for callbacks.
/// The delegate can also be set at a later point using <code>Fairmatic/setDelegate(_:)</code>
/// method.
///
/// \param handler This block is called when fairmatic setup completes.
/// The application is expected to use the success and error
/// params passed to this block to handle failures. The handler
/// would be invoked on the main thread. Can be nil.
///
+ (void)setupWithConfiguration:(FairmaticConfiguration * _Nonnull)configuration delegate:(id <FairmaticDelegate> _Nullable)delegate completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))handler;
/// Set delegate to receive callbacks for various events from Fairmatic SDK.
/// See <code>FairmaticDelegate</code> for further details.
/// Calling this if Fairmatic is not setup is a no-op. See <code>setupWith(configuration:delegate:completionHandler:)</code> for further details.
/// \param delegate The delegate object to give callbacks on.
///
+ (void)setDelegate:(id <FairmaticDelegate> _Nullable)delegate;
/// The drive detection mode controls how Fairmatic SDK detects drives.
/// See <code>DriveDetectionMode</code> for further details.
/// Use this method to get the current <code>DriveDetectionMode</code>.
+ (enum FairmaticDriveDetectionMode)getDriveDetectionMode SWIFT_WARN_UNUSED_RESULT;
/// Change the drive detection mode to control how Fairmatic SDK detects drives.
/// See <code>DriveDetectionMode</code> for further details. This will override the mode sent
/// with <code>Configuration</code> during setup.
/// Calling this method stops an ongoing auto-detected drive.
/// If the SDK is not setup calling this method will result in a no-op.
/// \param driveDetectionMode The new drive detection mode.
///
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// success, A boolean that suggests if drive is started successfully
/// error, A valid <code>FairmaticError</code> is returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError/notSetup</code>
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)setDriveDetectionMode:(enum FairmaticDriveDetectionMode)driveDetectionMode completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Stops driving data collection. The application can disable the Fairmatic SDK
/// by invoking this method. This method is asynchronous.
/// The teardown method is internally synchronized with
/// <code>setupWith(configuration:delegate:completionHandler:)</code> method, and the enclosing application should avoid synchronizing the two methods independently. Calling this
/// with nil completion handler is same as calling teardown method.
/// \param handler Called when method completes. The handler would be invoked on main thread. Can be nil.
///
+ (void)teardownWithCompletionHandler:(void (^ _Nullable)(void))handler;
/// Wipe out all the data that Fairmatic keeps locally on the device.
/// When Fairmatic SDK is torn down, trip data that is locally persisted continues to remain persisted.
/// The data will be uploaded when SDK setup is called at a later time.
/// Wipeout should be used when the application wants to remove all traces of Fairmatic on the device.
/// Data cannot be recovered after this call.
/// <blockquote>
/// This call can only be made when the SDK is not running.
/// Call <code>teardown(completionHandler:)</code> to tear down a live SDK before making this call else <code>FairmaticError/notTornDown</code> will be reported
///
/// </blockquote>
+ (void)wipeOutWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// This API allows application to override Fairmatic’s auto drive detection
/// algorithm.
/// Invoking this method forces the start of a drive. If this API is
/// used then it is application’s responsibility to terminate the drive by
/// invoking <code>stopManualDrive(completionHandler:)</code> method. If an auto-detected drive is in progress, that drive
/// is stopped and a new drive is started.
/// These methods should be used only by applications which have explicit
/// knowledge of start and end of drives and want to attribute drive data to
/// specific trackingIds.
/// Calling it without having initialized the Fairmatic framework
/// <code>setupWith(configuration:delegate:completionHandler:)</code> is a no-op.
/// Calling <code>startManualDrive(trackingId:completionHandler:)</code> with the same trackingId without calling <code>stopManualDrive(completionHandler:)</code> in between
/// is a no-op. Calling <code>startManualDrive(trackingId:completionHandler:)</code> with a different trackingId: with implicitly call <code>stopManualDrive(completionHandler:)</code> before starting a new drive.
/// This is an asynchronous method, <code>FairmaticDelegate/processStart(ofDrive:)</code>
/// is triggered once this finishes with basic information about the drive. <code>activeDriveInfo</code> will return <code>nil</code> until <code>FairmaticDelegate/processStart(ofDrive:)</code> is called
/// You need to call <code>stopManualDrive(completionHandler:)</code> to stop drive data collection.
/// \param trackingId Optional identifier which allows identifying this drive uniquely. If this value is <code>nil</code>, the SDK will supply a default trackingId.
/// It may not be an empty string. It will be truncated to 64 characters if it is longer than 64 characters. Passing invalid <code>trackingId</code> is an error. Please use <code>isValidInputParameter(_:)</code> to validate the trackingId.
///
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// <code>success</code>:  A boolean that suggests if drive is started successfully
/// <code>error</code>: A valid <code>FairmaticError</code> is returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError/notSetup</code>, <code>FairmaticError/invalidTrackingId</code>
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)startManualDriveWithTrackingId:(NSString * _Nullable)trackingId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// This should be called to indicate the end of a drive started by invoking
/// <code>startManualDrive(trackingId:completionHandler:)</code>
/// This block has no return value and two arguments:
/// the error, A valid <code>FairmaticError</code> is returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError/notSetup</code>, <code>FairmaticError/invalidTrackingId</code>,
/// <code>FairmaticError/internalFailure</code>.
/// Refer to <code>FairmaticError</code> for more details on the errors.
/// <ul>
///   <li>
///     <code>success</code> boolean that suggests if drive is stopped successfully
///   </li>
/// </ul>
/// Calling it without having initialized the Fairmatic SDK is a no-op.
+ (void)stopManualDriveWithCompletionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Start a session in the SDK.
/// Applications which want to record several user’s drives as a session may use
/// this call.
/// All drives, either automatically detected or started using <code>startManualDrive(trackingId:completionHandler:)</code>,
/// will be tagged with the sessionId if a session is already in progress. If a drive
/// is already on when this call is made, that drive will not belong to this
/// session.
/// This session id will be made available as a query parameter in the
/// reports and API that Fairmatic provides.
/// The application must call <code>stopSession()</code> when it wants to end the session.
/// Only one session may be active at a time. Calling <code>startSession(_:)</code> when a session is
/// already active with a new <code>sessionId</code> will stop the ongoing session and start a new
/// one.
/// Calling it without having initialized the Fairmatic SDK is a no-op.
/// \param sessionId an identifier that identifies this session uniquely. Cannot
/// be null or an empty string. Cannot be longer than 64 characters.
/// Use <code>isValidInputParameter(_:)</code> to verify that <code>sessionId</code> is valid.
/// Passing invalid string is a no-op.
///
+ (void)startSession:(NSString * _Nonnull)sessionId;
/// Stop currently ongoing session. No-op if no session is ongoing. Trips that
/// start after this call do not belong to the session. Ongoing trips at the time of this
/// call will continue to belong to the session that was just stopped. Also see <code>startSession(_:)</code>
+ (void)stopSession;
/// Use this method to check whether the parameter string passed
/// to the SDK is valid.
/// All strings passed as input params to Fairmatic SDK cannot contain
/// the following characters-
/// “?”, “ “, “&”, “/”, “", “;”, “#”
/// Non-ascii characters are not allowed.
/// \param input The string to validate.
///
///
/// returns:
/// <code>true</code> if the string is <code>nil</code> or valid, <code>false</code> otherwise.
+ (BOOL)isValidInputParameter:(NSString * _Nullable)input SWIFT_WARN_UNUSED_RESULT;
/// Returns an identifier which can be used to identify this SDK build.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull buildVersion;)
+ (NSString * _Nonnull)buildVersion SWIFT_WARN_UNUSED_RESULT;
/// Get info on the currently active drive. If sdk is not setup or if
/// no drive is in progress, nil is returned.
///
/// returns:
/// The currently active drive information.
+ (FairmaticActiveDriveInfo * _Nullable)activeDriveInfo SWIFT_WARN_UNUSED_RESULT;
/// Returns a boolean indicating whether Fairmatic SDK can detect accidents
/// on this devices or not.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL isAccidentDetectionSupportedByDevice;)
+ (BOOL)isAccidentDetectionSupportedByDevice SWIFT_WARN_UNUSED_RESULT;
/// Returns a NSDictionary with keys as <code>EventType</code> and values being Bool which represent
/// if a particular event will be detected by the SDK on this device.
+ (NSDictionary * _Nonnull)getEventSupportForDevice SWIFT_WARN_UNUSED_RESULT;
/// Send a debug report of the current driver to Fairmatic.
/// The Fairmatic SDK will create a background task to ensure the
/// completion of this upload task.
+ (void)uploadAllDebugDataAndLogs;
/// This <code>Settings</code> class surfaces errors in the device or application settings that affect trip detection in the SDK.
/// Your application should check this object to ensure that the SDK is set up correctly and has all the necessary permissions
/// to detect trips accurately.
///
/// returns:
/// A valid <code>Settings</code> object if the SDK is setup, otherwise nil.
+ (FairmaticSettings * _Nullable)getSettings SWIFT_WARN_UNUSED_RESULT;
/// Logs all the critical permissions required by the SDK
/// \param sdkHealthReason indicates the reason for logging SDK Health
///
+ (void)logSDKHealth:(enum FairmaticSDKHealthReason)reason completionHandler:(void (^ _Nonnull)(NSError * _Nullable))completionHandler;
@end


@interface Fairmatic (SWIFT_EXTENSION(FairmaticSDK))
/// Start Fairmatic insurance period 1 in the SDK.
/// A manual trip of a default trackingId will be started immediately on this call.
/// The entire duration in this period will be recorded as a single trip.
/// If period 1 is already in progress with the same trackingId, this call will be a no-op.
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// A boolean that suggests successful completion of the call
/// and a valid <code>FairmaticError</code> is returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError/notSetup</code>, <code>FairmaticError/insurancePeriodSame</code>,
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)startDriveWithPeriod1:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Start Fairmatic insurance period 2 in the SDK.
/// A manual trip of id trackingId will be started immediately on this call.
/// The entire duration in this period will be recorded as a single trip.
/// If period 2 is already in progress with the same trackingId, this call will be a no-op.
/// \param trackingId An identifier which allows identifying this drive uniquely.
/// This drive identifier must be unique for the user.
///
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// A boolean that suggests successful completion of the call
/// and a valid <code>FairmaticError</code> is returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError/notSetup</code>, <code>FairmaticError/insurancePeriodSame</code>,
/// <code>FairmaticError/invalidTrackingId</code>.
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)startDriveWithPeriod2:(NSString * _Nonnull)trackingId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Start Fairmatic insurance period 3 in the SDK.
/// A manual trip of id trackingId will be started immediately on this call.
/// The entire duration in this period will be recorded as a single trip.
/// If period 3 is already in progress with the same trackingId, this call will be a no-op.
/// \param trackingId An identifier which allows identifying this drive uniquely.
/// This drive identifier must be unique for the user.
///
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// A boolean that suggests successful completion of the call
/// and a valid error <code>FairmaticError</code> is returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError/notSetup</code>, <code>FairmaticError/insurancePeriodSame</code>,
/// <code>FairmaticError/invalidTrackingId</code>.
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)startDriveWithPeriod3:(NSString * _Nonnull)trackingId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Stop currently ongoing Fairmatic insurance period if any.
/// Ongoing trips at the time of this call will be stopped.
/// Auto trip detection is turned off on this call.
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// A boolean that suggests successful completion of the call
/// and a valid <code>FairmaticError</code> is returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError/notSetup</code>.
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)stopPeriod:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
@end


/// Delegate for <code>Fairmatic</code>.
/// <h2>See Also</h2>
/// <ul>
///   <li>
///     <code>Fairmatic/setDelegate(_:)</code>
///   </li>
///   <li>
///     <code>Fairmatic/setupWith(configuration:delegate:completionHandler:)</code>
///   </li>
/// </ul>
SWIFT_PROTOCOL_NAMED("FairmaticDelegate") SWIFT_AVAILABILITY(ios,introduced=13.0)
@protocol FairmaticDelegate <NSObject>
@optional
/// Called on delegate in the main thread when <code>Fairmatic</code> SDK detects a potential
/// start of a drive.
/// \param startInfo Info about drive start. Refer to <code>DriveStartInfo</code> for further details.
///
- (void)processStartOfDrive:(FairmaticDriveStartInfo * _Nonnull)startInfo;
/// Called on delegate in the main thread when <code>Fairmatic</code> SDK resumes a
/// drive after a gap.
/// The gap in drive recording may occur due to an application restart by the OS,
/// application kill and restart by a user, an application crash or other reasons.
/// Drives started by calling <code>Fairmatic/startManualDrive(trackingId:completionHandler:)</code> are always resumed and they
/// will not end until <code>Fairmatic/stopManualDrive(completionHandler:)</code> is called.
/// \param resumeInfo Info about drive resume. Refer to <code>DriveResumeInfo</code> for further details.
///
- (void)processResumeOfDrive:(FairmaticDriveResumeInfo * _Nonnull)resumeInfo;
/// Called on the delegate on the main thread when <code>Fairmatic</code> SDK detects a drive to have been completed.
/// It is possible that <code>Fairmatic</code> SDK might decide at a later time that an
/// ongoing trip was a falsely detected trip. In such scenario <code>processEnd(ofDrive:)</code> will be invoked on delegate with <code>DriveInfo/driveType</code> set to <code>DriveType/invalid</code>.
/// Every trip with <code>DriveInfo/driveType</code> not set to <code>DriveType/invalid</code>
/// will receive a corresponding <code>processAnalysis(ofDrive:)</code> callback containing
/// additional info related to this drive.
/// \param estimatedDriveInfo Best estimate info about the drive.
/// Refer to <code>EstimatedDriveInfo</code> for further details.
///
- (void)processEndOfDrive:(FairmaticEstimatedDriveInfo * _Nonnull)estimatedDriveInfo;
/// Called on the delegate in the main thread when <code>Fairmatic</code> SDK finishes
/// full analysis of all valid drives returned from <code>processEnd(ofDrive:)</code> callback.
/// This will be called for all the <code>processEnd(ofDrive:)</code> callbacks
/// with the value of <code>DriveInfo/driveType</code> not set to <code>DriveType/invalid</code>.
/// This may contain additional or improved data over the <code>EstimatedDriveInfo</code>
/// returned from <code>processEnd(ofDrive:)</code>
/// Typically this callback will be fired within a few seconds after <code>processEnd(ofDrive:)</code> callback but in some rare cases this delay can be really large depending on phone network conditions.
/// This callback will be fired in trip occurrence sequence, i.e from oldest trip to
/// the latest trip.
/// \param analyzedDriveInfo Analyzed insights of the drive.
///
- (void)processAnalysisOfDrive:(FairmaticAnalyzedDriveInfo * _Nonnull)analyzedDriveInfo;
/// [Disabled by default]
/// This callback is fired on the main thread when a potential accident is detected by the SDK during a drive.
/// This is a preliminary callback of a potential collision. This collision is confirmed or invalidated by <code>processAccidentDetected(_:)</code> callback.
/// <blockquote>
/// This is disabled by default. To enable, reach out to your contact at Fairmatic
///
/// </blockquote>
/// \param accidentInfo Info about accident.
///
- (void)processPotentialAccidentDetected:(FairmaticAccidentInfo * _Nonnull)accidentInfo;
/// This callback is fired on the main thread when an accident is detected by
/// the SDK during a drive. Any ongoing auto-detected/manual drives will be stopped
/// after this point.
/// \param accidentInfo Info about accident.
///
- (void)processAccidentDetected:(FairmaticAccidentInfo * _Nonnull)accidentInfo;
/// This callback gives information about errors in device or application settings that
/// may be affecting Fairmatic SDK.
/// This callback is fired on the main thread after SDK setup and whenever
/// location permission or <code>Configuration/driveDetectionMode</code> changes,
/// provided the location permission is determined.
/// The recommended flow is to ask for the permissions before SDK is setup
/// because if the location permission is not determined this callback will not be
/// fired.
/// If you receive this callback in the foreground you can show the errors using  any UI
/// constructs like alert controllers, if this callback is received in the background you can
/// use a notification. If you want to add actions to the notification then please don’t
/// rely on errors received at the time of notification as they might have changed by
/// the time the user clicks on the notification. Instead use <code>Fairmatic/getSettings()</code>
/// to get the latest errors and show appropriate message to the user.
/// \param settings A valid <code>Settings</code> object that contains
/// information about errors affecting the Fairmatic SDK.
///
- (void)settingsChanged:(FairmaticSettings * _Nonnull)settings;
@end

/// Error returned as code of <code>NSError</code> from <code>Fairmatic</code> public APIs in case of
/// failures.
/// In case you are using Objective-C, the errors would be returned as <code>NSError</code> objects. In that case, you can use the <code>code</code> of the <code>NSError</code> to get the appropriate <code>FairmaticError</code>
/// \code
/// // Considering that the name of the variable is `nsError`,
/// // you can check the proper error code
/// // using the following format:
/// long code = (long) nsError.code
/// NSString *errorDescription = nsError.localizedDescription
/// NSLog(errorDescription)
///
/// if (errorCode == FairmaticErrorNotSetup) {
///     NSLog(@"Fairmatic SDK is not setup");
/// }
///
/// \endcodeYou can also cast the <code>code</code> of the error to <code>FairmaticError</code> enum to get the enum value like:
/// \code
/// FairmaticError errorCode = (FairmaticError) nsError.code
/// switch (fmError) {
///     case FairmaticErrorNotSetup:
///         NSLog(@"Fairmatic SDK is not setup");
///         break;
///     default:
///         break;
/// }
///
/// \endcode
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticError, "FairmaticError", open) {
/// SDK Key used in setup is invalid
  FairmaticErrorInvalidSDKKeyString = 0,
/// Network not reachable, Fairmatic.setup sometimes needs network call
/// for authentication and to update SDK configuration to work. This error
/// is returned whenever network is not available in these scenarios.
  FairmaticErrorNetworkUnreachable = 1,
/// Fairmatic SDK does not support the OS version of the device.
  FairmaticErrorUnsupportedOSVersion = 2,
/// Fairmatic SDK does not support the device type.
  FairmaticErrorDeviceUnsupported = 3,
/// Invalid parameter was passed to the API.
  FairmaticErrorInvalidParams = 101,
/// Internal error.
  FairmaticErrorInternalFailure = 102,
/// Fairmatic SDK is not setup. This error is also returned in case SDK setup has started but completion handler for setup is not called yet.
  FairmaticErrorNotSetup = 103,
/// Insurance Period hasn’t changed from the previously active period, action ignored.
/// This error may be returned from <code>Fairmatic/startDriveWithPeriod1(_:)</code>, <code>Fairmatic/startDriveWithPeriod2(_:completionHandler:)</code>,
/// <code>Fairmatic/startDriveWithPeriod3(_:completionHandler:)</code>.
  FairmaticErrorInsurancePeriodSame = 104,
/// Invalid <code>trackingId</code> passed for new drive. This error may be returned from
/// <code>Fairmatic/startDriveWithPeriod2(_:completionHandler:)</code>,
/// <code>Fairmatic/startDriveWithPeriod3(_:completionHandler:)</code>.
  FairmaticErrorInvalidTrackingId = 105,
/// Fairmatic SDK is not torn down. This error is returned if the requested operation cannot
/// be completed while the SDK is running like the <code>Fairmatic/wipeOut(completion:)</code> API.
  FairmaticErrorNotTornDown = 106,
/// Some IO error occured while doing the operation. Refer to error description for more info.
  FairmaticErrorIoError = 107,
/// User is not authorized to use this application.
  FairmaticErrorUserDeprovisioned = 111,
/// Operation failed because the set vehicle type feature is disabled in the config.
  FairmaticErrorUnsupportedVehicleType = 112,
/// This error is thrown when the size of the fleet has exceeded the limit. Please get in touch with your contact at Fairmatic to increase the limit.
  FairmaticErrorFleetSizeLimitExceeded = 1002,
/// This error is thrown by the <code>Fairmatic/setupWith(configuration:delegate:completionHandler:)</code> API when the driver associated with the provided <code>Configuration/driverId</code> has been deleted. Please get in touch with your contact at Fairmatic with the <code>driverId</code>.
  FairmaticErrorDriverDeleted = 1003,
/// This error is thrown by the <code>Fairmatic/setupWith(configuration:delegate:completionHandler:)</code> API when you provide the driver name provided in <code>DriverAttributes</code> is invalid. Please use a non-empty string as name when calling <code>DriverAttributes/init(name:email:phoneNumber:)</code>
  FairmaticErrorInvalidDriverName = 1004,
};
static NSString * _Nonnull const FairmaticErrorDomain = @"FairmaticSDK.FairmaticError";

@class FairmaticMockAccidentConfig;

/// This class contains methods that mock Fairmatic’s functionality for testing purposes.
SWIFT_CLASS_NAMED("FairmaticTest") SWIFT_AVAILABILITY(ios,introduced=13.0)
@interface FairmaticTest : NSObject
/// Use this method to test <code>Fairmatic</code> Accident detection integration. Works only in
/// <code>DEBUG</code> mode, disabled in <code>RELEASE</code> mode.
/// On invoking this method, you will get a final accident callback <code>FairmaticDelegate/processAccidentDetected(_:)</code> on your
/// delegate after 5 seconds. You can look at console logs for debugging in case you
/// do not receive the callback. If issue persists, reach out to your contact at Fairmatic.
/// warning:
/// While invoking this method on a simulator, make sure your are simulating
/// location (In Simulator menu bar, select Features->Location->Apple).
/// \param confidence Any value from <code>AccidentConfidence</code> enum.
///
+ (void)raiseMockAccident:(enum FairmaticAccidentConfidence)confidence;
/// Use this method to test <code>Fairmatic</code> Accident detection integration. Works only in <code>DEBUG</code> mode,
/// disabled in <code>RELEASE</code> mode.
/// This API can be used to test multiple callbacks. You need to enable <code>Configuration/implementsMultipleAccidentCallbacks</code>
/// for that.
/// In case of multiple callbacks enabled, on invoking this method, you will get a potential accident callback
/// on your delegate. After <code>MockAccidentConfig/delayBetweenCallbacks</code> seconds, you will
/// get a final accident callback.
/// In case only single callback is enabled by setting <code>Configuration/implementsMultipleAccidentCallbacks</code> as <code>false</code>,
/// on invoking this method, you will get a final accident callback that is <code>FairmaticDelegate/processAccidentDetected(_:)</code>.
/// You can look at console logs for debugging in case you do not receive the callback.
/// If issue persists, reach out to your contact at Fairmatic.
/// warning:
/// While invoking this method on a simulator, make sure your are simulating
/// location (In Simulator menu bar, select Features->Location->Apple).
/// \param config Configuration which determines the <code>AccidentInfo</code> values in the two callbacks.
///
+ (void)raiseMockAccidentUsing:(FairmaticMockAccidentConfig * _Nonnull)config;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class FairmaticScannedBeaconInfo;

/// This class provides helper methods for scaning beacons in the proximity.
SWIFT_CLASS_NAMED("FairmaticVehicleTagging")
@interface FairmaticVehicleTagging : NSObject
/// Get all the beacons which are in the device’s range.
/// Example:
/// \code
/// FairmaticVehicleTagging.getNearbyBeacons(uuid: "FD94C06F-8667-46C2-A334-14C6BF8EDEC3",
///  major: 100,
///  minor: 100,
///  completionHandler: { (beaconsList: [ScannedBeaconInfo], error:  NSError?) -> Void in
///      if let error = error {
///          // handle the error
///      }
///
///     // update scanned beacons list in state or redraw UI
///     })
///
/// \endcode\param uuid The UUID of the beacons that are to be scanned.
///
/// \param major The major of the beacons that are to be scanned.
///
/// \param minor The minor of the beacons that are to be scanned.
///
/// \param completionHandler The completion handler which is to be executed after the completion of beacon scan.
///
+ (void)getNearbyBeaconsWithUuid:(NSString * _Nonnull)uuid major:(int32_t)major minor:(int32_t)minor completionHandler:(void (^ _Nonnull)(NSArray<FairmaticScannedBeaconInfo *> * _Nonnull, NSError * _Nullable))completionHandler;
/// Get all the beacons which are in the device’s range.
/// Example:
/// \code
/// FairmaticVehicleTagging.getNearbyBeacons(uuid: "FD94C06F-8667-46C2-A334-14C6BF8EDEC3",
///  completionHandler: { (beaconsList: [ScannedBeaconInfo], error:  NSError?) -> Void in
///      if let error = error {
///          // handle the error
///      }
///     // update scanned beacons list in state or redraw UI
///     })
///
/// \endcode\param uuid The UUID of the beacons that are to be scanned.
///
/// \param completionHandler The completion handler which is to be executed after the completion of beacon scan.
///
+ (void)getNearbyBeaconsWithUuid:(NSString * _Nonnull)uuid completionHandler:(void (^ _Nonnull)(NSArray<FairmaticScannedBeaconInfo *> * _Nonnull, NSError * _Nullable))completionHandler;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// Error returned as code to <code>NSError</code> from <code>FairmaticVehicleTagging</code> public APIs in case of failures.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticVehicleTaggingError, "FairmaticVehicleTaggingError", open) {
/// Fairmatic SDK is not setup. This error is also returned in case SDK setup has started but completion handler for setup is not called yet.
/// <h2>See Also</h2>
/// <ul>
///   <li>
///     <code>Fairmatic/setupWith(configuration:delegate:completionHandler:)</code>
///   </li>
/// </ul>
  FairmaticVehicleTaggingErrorNotSetup = 0,
/// <code>FairmaticVehicleTagging/getNearbyBeacons(uuid:major:minor:completionHandler:)</code> failed to scan for beacons.
  FairmaticVehicleTaggingErrorBeaconScanTimeout = 6,
/// An unknown error occured in the Vehicle Tagging APIs. Please get in touch your contact at Fairmatic for further assistance.
  FairmaticVehicleTaggingErrorUnknownError = 1000,
};
static NSString * _Nonnull const FairmaticVehicleTaggingErrorDomain = @"FairmaticSDK.FairmaticVehicleTaggingError";

/// The types of insurance period in <code>Fairmatic</code>
/// Each drive belongs to exactly one of these insurance periods.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticInsurancePeriod, "InsurancePeriod", open) {
/// Applications that do not use Insurance APIs will have drives with this value for insurance period
  FairmaticInsurancePeriodNoPeriod = 0,
/// Drives undertaken with insurance period 1 will have this value.
/// Refer: <code>Fairmatic/startDriveWithPeriod1(_:)</code>
  FairmaticInsurancePeriodPeriod1 = 1,
/// Drives undertaken with insurance period 2 will have this value.
/// Refer: <code>Fairmatic/startDriveWithPeriod2(_:completionHandler:)</code>
  FairmaticInsurancePeriodPeriod2 = 2,
/// Drives undertaken with insurance period 3 will have this value.
/// Refer: <code>Fairmatic/startDriveWithPeriod3(_:completionHandler:)</code>
  FairmaticInsurancePeriodPeriod3 = 3,
};


/// Represents a geographical coordinate.
SWIFT_CLASS_NAMED("LocationPoint")
@interface FairmaticLocationPoint : NSObject
/// Epoch timestamp of the location point.
@property (nonatomic, readonly) int64_t timestamp;
/// Latitude in degrees
@property (nonatomic, readonly) double latitude;
/// Longitude in degrees
@property (nonatomic, readonly) double longitude;
/// Compares any object with LocationPoint.
/// \param object an object to be compared with this LocationPoint object.
///
///
/// returns:
/// <code>true</code> if the given object is equal to this LocationPoint object,
/// <code>false</code> otherwise.
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// Returns a dictionary that represents the <code>LocationPoint</code> object.
- (NSDictionary * _Nonnull)toDictionary SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// This class contains parameters required by <code>FairmaticTest/raiseMockAccident(using:)</code> for testing accident flow.
SWIFT_CLASS_NAMED("MockAccidentConfig")
@interface FairmaticMockAccidentConfig : NSObject
/// This field specifies the confidence for the potential accident callback -  <code>FairmaticDelegate/processPotentialAccidentDetected(_:)</code>.
/// Default value is <code>AccidentConfidence/high</code>.
@property (nonatomic) enum FairmaticAccidentConfidence potentialAccidentConfidence;
/// This field specifies the confidence for the final accident callback - <code>FairmaticDelegate/processAccidentDetected(_:)</code>
/// Default value is <code>AccidentConfidence/high</code>.
@property (nonatomic) enum FairmaticAccidentConfidence finalAccidentConfidence;
/// This field specifies the confidence for the potential accident callback - <code>FairmaticDelegate/processPotentialAccidentDetected(_:)</code>.
/// Default value is 70.
@property (nonatomic) NSInteger potentialAccidentConfidenceNumber;
/// This field specifies the confidence number for the final accident callback - - <code>FairmaticDelegate/processAccidentDetected(_:)</code>
/// Default value is 70.
@property (nonatomic) NSInteger finalAccidentConfidenceNumber;
/// This field specifies the callback delay (in seconds) between the potential and final accident callback.
/// Default value is 20 seconds.
@property (nonatomic) NSInteger delayBetweenCallbacks;
/// This field specifies the vehicle type at the time of potential accident callback and final accident callback.
/// Default value is <code>VehicleType/car</code>.
@property (nonatomic) enum FairmaticVehicleType vehicleType;
/// This field specifies the collision severity at the time of potential accident callback and final accident callback.
/// Default value is <code>CollisionSeverity/high</code>.
@property (nonatomic) enum FairmaticCollisionSeverity collisionSeverity;
/// This field specifies the direction of impact at the time of potential accident callback and final accident callback.
/// Default value is <code>DirectionOfImpact/unknown</code>.
@property (nonatomic) enum FairmaticDirectionOfImpact directionOfImpact;
/// Creates a Fairmatic <code>MockAccidentConfig</code> object.
- (nonnull instancetype)init;
/// This method causes the final callback to invalidate the potential callback.
/// Invalidating final callbacks have confidence number as 0 and confidence as <code>AccidentConfidence.invalid</code>,
/// signifying that the accident send out via the potential accident callback on further analysis has been reclassified as <em>not</em> being an accident.
- (void)invalidateFinalCallback;
@end






/// The types of phone positions during a trip.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticPhonePosition, "PhonePosition", open) {
/// The case when <code>Fairmatic</code> was unable to determine the position of the phone during a trip.
  FairmaticPhonePositionUnknown = 0,
/// The case when <code>Fairmatic</code> was able to determine confidently that the phone was on mount during a trip.
  FairmaticPhonePositionMount = 1,
};

/// Dictates the reason for is logging SDK Health
/// The SDK health will be recorded when there is any update in permission from last recorded SDK health.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticSDKHealthReason, "SDKHealthReason", open) {
/// Indicates the reason is unknown.
/// This is the default value.
  FairmaticSDKHealthReasonUnknown = 0,
/// Indicates that the SDK health will be recorded due to silent push notification
  FairmaticSDKHealthReasonSilentPushNotification = 1,
/// Indicates that the SDK health will be recorded due to background processing
  FairmaticSDKHealthReasonBackgroundProcessing = 2,
};


/// Wrapper for beacons scanned using <code>FairmaticVehicleTagging/getNearbyBeacons(uuid:major:minor:completionHandler:)</code>.
SWIFT_CLASS_NAMED("ScannedBeaconInfo")
@interface FairmaticScannedBeaconInfo : NSObject
/// The UUID of the scanned beacon.
@property (nonatomic, readonly, copy) NSString * _Nonnull uuid;
/// The major of the scanned beacon.
@property (nonatomic, readonly) NSInteger major;
/// The minor of the scanned beacon.
@property (nonatomic, readonly) NSInteger minor;
/// The RSSI of the scanned beacon.
@property (nonatomic, readonly) NSInteger rssi;
/// Constants that reflect the relative distance to a beacon.
@property (nonatomic, readonly) CLProximity proximity;
/// The accuracy of the proximity value, measured in meters from the beacon.
@property (nonatomic, readonly) CLLocationAccuracy accuracy;
/// The timestamp representing when the beacon was observed.
@property (nonatomic, readonly) int64_t timestamp;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class FairmaticSettingsError;

/// This class surfaces errors in device or application settings that affects trip detection in the SDK.
SWIFT_CLASS_NAMED("Settings")
@interface FairmaticSettings : NSObject
/// List of errors that must be resolved for trip detection to work correctly.
@property (nonatomic, readonly, copy) NSArray<FairmaticSettingsError *> * _Nonnull errors;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


enum FairmaticSettingsErrorType : NSInteger;

/// This class represent an error in device or application settings that is affecting
/// the ability of the SDK to detect trips.
SWIFT_CLASS_NAMED("SettingsError")
@interface FairmaticSettingsError : NSObject
/// Error type for SettingsError
@property (nonatomic, readonly) enum FairmaticSettingsErrorType errorType;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Error type for <code>SettingsError</code>
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticSettingsErrorType, "SettingsErrorType", open) {
/// The location authorization status is determined but the user hasn’t granted
/// the <em>Always</em> location authorization to the application.
  FairmaticSettingsErrorTypeLocationPermissionNotAuthorized = 0,
/// The activity authorization status is determined but the user has <em>not authorized</em> application to
/// access the motion and fitness data. This error will only be thrown if activity based trip detection
/// is enabled for the application.
/// note:
/// if the current drive detection is <em>not</em> <code>DriveDetectionMode/autoON</code>, this
/// error will not be thrown.
  FairmaticSettingsErrorTypeActivityPermissionNotAuthorized = 1,
/// The location authorization is <em>Always</em> but location accuracy authorization
/// is <em>not</em> <code>CLAccuracyAuthorizationFullAccuracy</code>.
  FairmaticSettingsErrorTypeLocationAccuracyAuthorizationReduced = 2,
/// The location service is turned off.
  FairmaticSettingsErrorTypeLocationServiceOff = 3,
};


/// A valid object of this class is returned in <code>Event/speedingData</code>
/// whenever <code>Event/eventType</code> is equal to <code>EventType/overSpeeding</code>.
SWIFT_CLASS_NAMED("SpeedingData")
@interface FairmaticSpeedingData : NSObject
/// The speed limit in meters per second.
@property (nonatomic, readonly) double speedLimitMPS;
/// The average speed of the user during this speeding event duration in meters per second.
@property (nonatomic, readonly) double userSpeedMPS;
/// Maximum speed of the user during this speeding event duration in meters per second.
@property (nonatomic, readonly) double maxUserSpeedMPS;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


enum FairmaticTripWarningType : NSInteger;

/// Represents a single warning that might have occurred during your trip.
/// A collection of these warnings are provided using the
/// <code>FairmaticDelegate/processAnalysis(ofDrive:)</code> callback.
SWIFT_CLASS_NAMED("TripWarning")
@interface FairmaticTripWarning : NSObject
/// The type of the trip warning.
@property (nonatomic, readonly) enum FairmaticTripWarningType tripWarningType;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The value return from <code>TripWarning/tripWarningType</code>.
/// Enum representing warnings detected for the current drive.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticTripWarningType, "TripWarningType", open) {
/// The trip duration is unexpectedly large and signifies a possible integration issue.
  FairmaticTripWarningTypeUnexpectedTripDuration = 0,
};

/// This is returned in <code>Event/turnDirection</code>, it represents the turn direction for <code>EventType/hardTurn</code>
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticTurnDirection, "TurnDirection", open) {
/// This is returned for all <code>Event/eventType</code> values other than <code>EventType/hardTurn</code>
  FairmaticTurnDirectionNotAvailable = 0,
/// Indicates that the turn direction of the event was left.
  FairmaticTurnDirectionLeft = 1,
/// Indicates that the turn direction of the event was right.
  FairmaticTurnDirectionRight = 2,
};

/// The value return from <code>DriveInfo/userMode</code>. Indicates whether user
/// was a driver or passenger.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticUserMode, "UserMode", open) {
/// Indicates that the user was in the driver seat.
/// All values in <code>DriveInfo</code> will be set.
  FairmaticUserModeDriver = 0,
/// Indicates that the user was in the passenger seat.
  FairmaticUserModePassenger = 1,
/// Indicates that either <code>DriveInfo/driveType</code> is not
/// <code>DriveType/drive</code> or <code>Fairmatic</code> was not able to determine user mode.
/// All values in <code>DriveInfo</code> will be set.
  FairmaticUserModeUnavailable = 2,
};

/// Type of vehicle used in the drive recorded by the Fairmatic SDK.
/// A default vehicle type can be set using <code>DriverAttributes/setVehicleType(_:)</code>
/// in <code>DriverAttributes</code>. The detected type is returned to the application in the <code>DriveInfo/vehicleType</code>
/// field of the <code>FairmaticDelegate/processAnalysis(ofDrive:)</code> callback.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticVehicleType, "VehicleType", open) {
/// Indicates a car vehicle type.
  FairmaticVehicleTypeCar = 0,
/// Indicates a motorcycle vehicle type.
  FairmaticVehicleTypeMotorcycle = 1,
/// Indicates that the user was not driving.
  FairmaticVehicleTypeUnknown = -1,
};







#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
#ifndef FAIRMATICSDK_SWIFT_H
#define FAIRMATICSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreLocation;
@import Foundation;
@import ObjectiveC;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="FairmaticSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)
/// Confidence measure of the detected accident.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticAccidentConfidence, "AccidentConfidence", open) {
/// Accident was detected with a high confidence. The application might inform
/// emergency services directly after waiting for some time for user feedback.
  FairmaticAccidentConfidenceHigh = 0,
/// Accident was detected, but with a low confidence. The application might ask
/// the user for feedback before notifying any emergency services.
  FairmaticAccidentConfidenceLow = 1,
/// Confidence of an invalidating callback. This might be sent only when the application has opted into multiple accident callbacks
  FairmaticAccidentConfidenceInvalid = 2,
};

@class NSString;
@class FairmaticLocationPoint;
enum FairmaticVehicleType : NSInteger;
enum FairmaticCollisionSeverity : NSInteger;
enum FairmaticDirectionOfImpact : NSInteger;

/// Wrapper for meta-information related to an accident detected by the SDK.
SWIFT_CLASS_NAMED("AccidentInfo")
@interface FairmaticAccidentInfo : NSObject
/// The unique Id of drive during which the accident occured
@property (nonatomic, readonly, copy) NSString * _Nonnull driveId;
/// The location of the accident.
@property (nonatomic, readonly, strong) FairmaticLocationPoint * _Nonnull accidentLocation;
/// The timestamp of the accident in milliseconds since epoch.
@property (nonatomic, readonly) int64_t timestamp;
/// The session that was in progress when the accident occured, if a session
/// was started in the SDK.
/// See <code>Fairmatic/startSession(_:)</code>
@property (nonatomic, readonly, copy) NSString * _Nullable sessionId;
/// The tracking id of the ongoing drive when the accident occured.
/// <ul>
///   <li>
///     See: <code>Fairmatic/startManualDrive(trackingId:completionHandler:)</code>
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSString * _Nullable trackingId;
/// The confidence of detected accident.
@property (nonatomic, readonly) enum FairmaticAccidentConfidence confidence;
/// Measures an approximate precision of the detected collision. Ranges between 0 to 100.
/// Note: A confidence number of 0 indicated that it was <em>not</em> an accident.
/// 0 confidence number can be sent as a part of potential accident callback
/// to invalidate the previous callback final accident callback for the same accident.
/// 0 confidence number will never come as a part of potential accident callback.
/// Checkout <code>MockAccidentConfig/invalidateFinalCallback()</code> to test this scenario during development.
@property (nonatomic, readonly) NSInteger confidenceNumber;
/// A unique identifier of this accident.
@property (nonatomic, readonly, copy) NSString * _Nonnull accidentId;
/// Vehicle type detected by SDK at the time of the accident.
/// Default value is <code>VehicleType/car</code>.
@property (nonatomic, readonly) enum FairmaticVehicleType vehicleType;
/// This field specifies the collision severity at the time of potential accident callback and final accident callback.
/// Default value is <code>CollisionSeverity/unknown</code>.
@property (nonatomic, readonly) enum FairmaticCollisionSeverity collisionSeverity;
/// This field specifies the direction of impact at the time of potential accident callback and final accident callback.
/// Default value is <code>DirectionOfImpact/unknown</code>.
@property (nonatomic, readonly) enum FairmaticDirectionOfImpact directionOfImpact;
/// Returns a dictionary that represents the <code>AccidentInfo</code> object.
- (NSDictionary * _Nonnull)toDictionary SWIFT_WARN_UNUSED_RESULT;
/// Returns a JSON formatted string that represents the <code>AccidentInfo</code> object.
- (NSString * _Nonnull)toJson SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum FairmaticInsurancePeriod : NSInteger;

/// Information about the active drive if any.
SWIFT_CLASS_NAMED("ActiveDriveInfo")
@interface FairmaticActiveDriveInfo : NSObject
/// The unique Id for this drive
@property (nonatomic, readonly, copy) NSString * _Nonnull driveId;
/// The start timestamp of trip in milliseconds since epoch.
@property (nonatomic, readonly) int64_t startTimestamp;
/// The insurance period for this drive
@property (nonatomic, readonly) enum FairmaticInsurancePeriod insurancePeriod;
/// The current speed of vehicle in meters/second.
@property (nonatomic, readonly) double currentSpeed;
/// The distance covered so far in this trip in meters.
@property (nonatomic, readonly) double distance;
/// Tracking id is specified by the enclosing application when it
/// wants to start a drive manually by calling <code>Fairmatic/startManualDrive(trackingId:completionHandler:)</code>
/// This may be the case for example in a taxi cab application that would
/// know when to start a drive based on when a meter gets flagged. The <code>trackingId</code> will be <code>nil</code> in case of auto detected drives.
@property (nonatomic, readonly, copy) NSString * _Nullable trackingId;
/// Session id is specified by the enclosing application when it wants to
/// record a session using <code>Fairmatic/startSession(_:)</code>
/// <code>sessionId</code> will be <code>nil</code> if there is no session associated with that drive.
@property (nonatomic, readonly, copy) NSString * _Nullable sessionId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum FairmaticDriveType : NSInteger;
enum FairmaticUserMode : NSInteger;
@class FairmaticEvent;
enum FairmaticPhonePosition : NSInteger;
@class FairmaticTripWarning;
@class FairmaticExtrapolationDetails;

/// Wrapper for meta-information related to a drive.
SWIFT_CLASS_NAMED("DriveInfo")
@interface FairmaticDriveInfo : NSObject
/// The unique Id for this drive
@property (nonatomic, readonly, copy) NSString * _Nonnull driveId;
/// The type of the drive. This decides what other info parameters will be populated.
/// A drive callback will be sent even for falsely detected drives or for non
/// automobile trips (Eg. biking, public transport).
@property (nonatomic, readonly) enum FairmaticDriveType driveType;
/// Whether the user was a driver or a passenger.
/// Driver/Passenger detection is disabled by default. Reach out to your
/// contact at Fairmatic to enable this feature.
/// Only present when <code>driveType</code> is
/// <code>DriveType/drive</code> and the SDK was able to determine with confidence
/// whether the user was a driver or a passenger.
/// If the SDK was not able to determine the user mode, this field is
/// <code>UserMode/unavailable</code>.
/// <blockquote>
/// Driver/Passenger detection is disabled by default
///
/// </blockquote>
@property (nonatomic, readonly) enum FairmaticUserMode userMode;
/// The insurance period for this drive
@property (nonatomic, readonly) enum FairmaticInsurancePeriod insurancePeriod;
/// The start timestamp of trip in milliseconds since epoch.
@property (nonatomic, readonly) int64_t startTimestamp;
/// The end timestamp of trip in milliseconds since epoch
@property (nonatomic, readonly) int64_t endTimestamp;
/// The average speed of trip in meters/second
@property (nonatomic, readonly) double averageSpeed;
/// The maximum speed of trip in meters/second
/// If we do not receive any accurate location data during the drive, this
/// property would be set to -1
@property (nonatomic, readonly) double maxSpeed;
/// The distance of the trip in meters
@property (nonatomic, readonly) double distance;
/// A list of <code>LocationPoint</code> objects corresponding to this trip in
/// increasing order of timestamp. The first point corresponds to trip start location
/// and last to trip end location.
/// This is a sampled approximation of the drive which gives an indication of
/// the path taken by the driver. It is not the full detailed location data of the drive.
/// If no waypoints are recorded during the drive, this is an empty array.
@property (nonatomic, readonly, copy) NSArray<FairmaticLocationPoint *> * _Nonnull waypoints;
/// Tracking id is specified by the enclosing application when it
/// wants to start a drive manually by calling <code>Fairmatic/startManualDrive(trackingId:completionHandler:)</code>
/// This may be the case for example in a taxi cab application that would
/// know when to start a drive based on when a meter gets flagged. trackingId will be
/// nil in case of auto detected drives.
@property (nonatomic, readonly, copy) NSString * _Nullable trackingId;
/// Session id is specified by the enclosing application when it wants to
/// record a session using <code>Fairmatic/startSession(_:)</code>
/// sessionId will be nil if there is no session associated with that drive.
@property (nonatomic, readonly, copy) NSString * _Nullable sessionId;
/// A list of <code>Event</code> objects for this trip in increasing order of timestamp.
/// In case of no events in the trip an empty list is returned.
@property (nonatomic, readonly, copy) NSArray<FairmaticEvent *> * _Nonnull events;
/// The position of the phone during this trip.
@property (nonatomic, readonly) enum FairmaticPhonePosition phonePosition;
/// A list of <code>TripWarning</code> objects for this trip.
/// In case of no warnings in the trip an empty list is returned.
@property (nonatomic, readonly, copy) NSArray<FairmaticTripWarning *> * _Nonnull tripWarnings;
/// The type of vehicle.
/// If <code>driveType</code> is not <code>DriveType/drive</code> then it will be set to <code>VehicleType/unknown</code>.
/// NOTE: This value will only be populated in <code>FairmaticDelegate/processAnalysis(ofDrive:)</code> callback.
@property (nonatomic, readonly) enum FairmaticVehicleType vehicleType;
/// The extrapolated details for a drive.
/// If <code>driveType</code> is not <code>DriveType/drive</code> then it will be set to nil.
@property (nonatomic, readonly, strong) FairmaticExtrapolationDetails * _Nullable extrapolationDetails;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// This contains the fully analyzed results for a drive, this is returned from
/// <code>FairmaticDelegate/processAnalysis(ofDrive:)</code> callback for all the trips with the value of
/// <code>DriveInfo/driveType</code> not set to <code>DriveType/invalid</code>.
/// The data of this type will always be of equal or better quality than
/// <code>EstimatedDriveInfo</code> returned from <code>FairmaticDelegate/processEnd(ofDrive:)</code>
/// Typically <code>FairmaticDelegate/processAnalysis(ofDrive:)</code> will be fired within
/// a few seconds after <code>FairmaticDelegate/processEnd(ofDrive:)</code> callback but in some rare cases
/// this delay can be really large depending on phone network conditions.
/// The callback for this <code>FairmaticDelegate/processAnalysis(ofDrive:)</code> will be fired in trip
/// occurrence sequence, i.e. from oldest trip to the latest trip.
SWIFT_CLASS_NAMED("AnalyzedDriveInfo")
@interface FairmaticAnalyzedDriveInfo : FairmaticDriveInfo
@end

/// Collision severity of the detected accident.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticCollisionSeverity, "CollisionSeverity", open) {
/// Unknown severity collision.
  FairmaticCollisionSeverityUnknown = 0,
/// Low severity collision
  FairmaticCollisionSeverityLow = 1,
/// High severity collision.
  FairmaticCollisionSeverityHigh = 2,
};

@class FairmaticDriverAttributes;
enum FairmaticDriveDetectionMode : NSInteger;

/// This class contains parameters required by <code>Fairmatic</code> during setup.
SWIFT_CLASS_NAMED("Configuration")
@interface FairmaticConfiguration : NSObject
/// Your SDK key.
/// Pass in the SDK key for your app.
/// This field is REQUIRED and should be a valid string.
/// Check <code>Fairmatic/isValidInputParameter(_:)</code> to validate this field. <code>nil</code> strings are not allowed.
/// Passing invalid string would cause SDK setup to fail.
@property (nonatomic, copy) NSString * _Nonnull sdkKey;
/// Unique ID for the current user. This can be any ID used by your app to
/// identify its users.
/// Use <code>Fairmatic/isValidInputParameter(_:)</code> to verify that <code>driverId</code> is valid.
/// This field is REQUIRED and should be a valid string.
/// Passing invalid string would cause SDK setup to fail.
@property (nonatomic, copy) NSString * _Nonnull driverId;
/// Attributes for the current user. These attributes are stored on the server
/// and are provided in Fairmatic’s APIs. Any existing attributes would be overwritten
/// on the server when a non-nil value for this param is passed. Passing nil is a no-op.
/// Use this param to provide meta-information about the user like name,
/// email, phone number or any custom attributes you wish to provide.
@property (nonatomic, strong) FairmaticDriverAttributes * _Nonnull driverAttributes;
/// Use this mode to control the SDK’s behaviour for detecting drives
/// automatically. This mode can be changed at a later point using
/// <code>Fairmatic/setDriveDetectionMode(_:completionHandler:)</code> method.
/// Applications which do not want the SDK to continuously track drives in
/// background should set this value to <code>DriveDetectionMode/autoOFF</code>. With this, the application needs to call <code>Fairmatic/startManualDrive(trackingId:completionHandler:)</code> method to record drives. In case the application wants to enable auto drive detection only for a fixed duration (like when the driver is on-duty), use method <code>Fairmatic/setDriveDetectionMode(_:completionHandler:)</code>
/// to change the mode to <code>DriveDetectionMode/autoON</code> for that period and set it back to <code>DriveDetectionMode/autoOFF</code> (once the driver goes off-duty).
@property (nonatomic) enum FairmaticDriveDetectionMode driveDetectionMode;
/// Developers have to set this property to <code>true</code> if the app implements multiple accident callbacks -
/// potential callback and final callback.
/// If set to <code>false</code>, the SDK assumes that potential accident callback is not implemented.
/// The default value of this property is <code>false</code>.
@property (nonatomic) BOOL implementsMultipleAccidentCallbacks;
/// Creates a Fairmatic <code>Configuration</code> object.
/// \param sdkKey The SDK key to be used to initialize the SDK. Refer <code>sdkKey</code> for more details
///
/// \param driverId The driver identifer. Refer <code>driverId</code> for more details.
///
/// \param driverAttributes The additional attributes for the driver.
///
- (nonnull instancetype)initWithSdkKey:(NSString * _Nonnull)sdkKey driverId:(NSString * _Nonnull)driverId driverAttributes:(FairmaticDriverAttributes * _Nonnull)driverAttributes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Direction of impact detected by SDK at the time of the accident
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticDirectionOfImpact, "DirectionOfImpact", open) {
/// Indicates an unknown direction of impact
  FairmaticDirectionOfImpactUnknown = 0,
/// Indicates a front direction of impact
  FairmaticDirectionOfImpactFront = 1,
/// Indicates a rear direction of impact
  FairmaticDirectionOfImpactRear = 2,
/// Indicates a broadside direction of impact
  FairmaticDirectionOfImpactBroadside = 3,
};


/// Dictates the functioning of Fairmatic’s drive detection.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticDriveDetectionMode, "DriveDetectionMode", open) {
/// <code>Fairmatic</code> SDK will automatically track drives in background in
/// this mode once the SDK is setup. At the same time, the application can invoke
/// <code>Fairmatic/startManualDrive(trackingId:completionHandler:)</code> to explicitly start recording a drive.
  FairmaticDriveDetectionModeAutoON = 0,
/// In this mode auto drive-detection is disabled. All other APIs on <code>Fairmatic</code>
/// can be invoked independent of this mode. For recording trips in this mode, the
/// application has to explicitly invoke the <code>Fairmatic/startManualDrive(trackingId:completionHandler:)</code> method.
  FairmaticDriveDetectionModeAutoOFF = 1,
/// In this mode drive detection is controlled by Insurance period APIs present in
/// <code>Fairmatic</code> class. Only insurance related APIs should be used in this mode to control <code>FairmaticSDK</code> behavior.
/// This is the Default mode.
/// <blockquote>
/// This is the Default mode.
///
/// </blockquote>
/// <h2>See Also</h2>
/// <ul>
///   <li>
///     <code>Fairmatic/startDriveWithPeriod1(_:)</code>
///   </li>
///   <li>
///     <code>Fairmatic/startDriveWithPeriod2(_:completionHandler:)</code>
///   </li>
///   <li>
///     <code>Fairmatic/startDriveWithPeriod3(_:completionHandler:)</code>
///   </li>
///   <li>
///     <code>Fairmatic/stopPeriod(_:)</code>
///   </li>
/// </ul>
  FairmaticDriveDetectionModeInsurance = 2,
};



/// Information about a drive that was resumed in the <code>Fairmatic</code> SDK.
/// This is called after the drive recording resumes after a gap. The gap may occur due to
/// an application restart by the OS, application kill and restart by a user, an application crash
/// etc.
SWIFT_CLASS_NAMED("DriveResumeInfo")
@interface FairmaticDriveResumeInfo : NSObject
/// The unique Id for this drive
@property (nonatomic, readonly, copy) NSString * _Nonnull driveId;
/// The insurance period for this drive
@property (nonatomic, readonly) enum FairmaticInsurancePeriod insurancePeriod;
/// The start timestamp of trip in milliseconds since epoch.
@property (nonatomic, readonly) int64_t startTimestamp;
/// The distance of the trip in meters
@property (nonatomic, readonly) double distance;
/// A list of <code>LocationPoint</code> objects corresponding to this trip in
/// increasing order of timestamp. The first point corresponds to trip start location
/// and last to trip end location.
/// This is a sampled approximation of the drive which gives an indication of
/// the path taken by the driver. It is not the full detailed location data of the drive.
/// If no waypoints are recorded during the drive, this is an empty array.
@property (nonatomic, readonly, copy) NSArray<FairmaticLocationPoint *> * _Nonnull waypoints;
/// Tracking id is specified by the enclosing application when it
/// wants to start a drive manually by calling <code>Fairmatic/startManualDrive(trackingId:completionHandler:)</code>
/// This may be the case for example in a taxi cab application that would
/// know when to start a drive based on when a meter gets flagged. trackingId will be
/// <code>nil</code> in case of auto detected drives.
@property (nonatomic, readonly, copy) NSString * _Nullable trackingId;
/// Session id is specified by the enclosing application when it wants to
/// record a session using <code>Fairmatic/startSession(_:)</code>
/// sessionId will be <code>nil</code> if there is no session associated with that drive.
@property (nonatomic, readonly, copy) NSString * _Nullable sessionId;
/// The start timestamp of the gap in drive recording in milliseconds.
/// The drive was resumed after this gap.
@property (nonatomic, readonly) int64_t driveGapStartTimestampMillis;
/// The end timestamp of the gap in drive recording in milliseconds.
/// The drive was resumed after this gap.
@property (nonatomic, readonly) int64_t driveGapEndTimestampMillis;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Information about start of a drive.
SWIFT_CLASS_NAMED("DriveStartInfo")
@interface FairmaticDriveStartInfo : NSObject
/// The unique Id for this drive
@property (nonatomic, readonly, copy) NSString * _Nonnull driveId;
/// The start timestamp of trip in milliseconds since epoch
@property (nonatomic, readonly) int64_t startTimestamp;
/// The insurance period for this drive
@property (nonatomic, readonly) enum FairmaticInsurancePeriod insurancePeriod;
/// The distance of the trip in meters
@property (nonatomic, readonly) double distance;
/// A list of <code>LocationPoint</code> objects corresponding to this trip in
/// increasing order of timestamp. The first point corresponds to trip start location.
/// This array contains a series of <code>LocationPoint</code> which
/// approximate the path taken by the driver. This is not the detailed location
/// data but rather a sample representing route geometry.
/// note:
/// The array might be empty if no accurate gps location is determined till
/// <code>FairmaticDelegate.processStart(ofDrive:)</code> call.
@property (nonatomic, readonly, copy) NSArray<FairmaticLocationPoint *> * _Nullable waypoints;
/// Tracking id is specified by the enclosing application when it
/// wants to start a drive manually by calling <code>Fairmatic/startManualDrive(trackingId:completionHandler:)</code>
/// This may be the case for example in a taxi cab application that would
/// know when to start a drive based on when a meter gets flagged. trackingId will be
/// nil in case of auto detected drives.
@property (nonatomic, readonly, copy) NSString * _Nullable trackingId;
/// Session id is specified by the enclosing application when it wants to
/// record a session using <code>Fairmatic/startSession(_:)</code>
/// <code>sessionId</code> will be nil if there is no session associated with that drive.
@property (nonatomic, readonly, copy) NSString * _Nullable sessionId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// The type of the drive returned from <code>DriveInfo/driveType</code>.
/// This decides what other <code>DriveInfo</code> parameters will be populated.
/// A drive callback can be sent as a false alarm or when we detect that the user was not
/// actually driving but moved using other means of transport.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticDriveType, "DriveType", open) {
/// Sometimes, the SDK detects that a trip is invalid after it has been started.
/// In these cases, the values for <code>DriveInfo/waypoints</code>, <code>DriveInfo/events</code>,
/// <code>DriveInfo/maxSpeed</code> and <code>DriveInfo/averageSpeed</code>
/// will have invalid values.
  FairmaticDriveTypeInvalid = 0,
/// This was not a driving trip. For e.g bike and train rides will fall under this trip type.
/// The <code>DriveInfo</code> will have <code>DriveInfo/waypoints</code>, <code>DriveInfo/maxSpeed</code>,
/// <code>DriveInfo/averageSpeed</code>, and <code>DriveInfo/events</code>.
  FairmaticDriveTypeNonDriving = 1,
/// This trip was taken in a valid <code>VehicleType</code>.
/// If the SDK determined the user to be a driver or a passenger, the value
/// will be available in <code>DriveInfo/userMode</code>
/// The <code>DriveInfo</code> will have <code>DriveInfo/waypoints</code>, <code>DriveInfo/maxSpeed</code>,
/// <code>DriveInfo/averageSpeed</code>,  and <code>DriveInfo/events</code>
  FairmaticDriveTypeDrive = 2,
};


/// Additional attributes of a <code>Fairmatic</code> driver.
/// The application can specify both predefined and custom attributes for a driver.
/// These attributes are associated with a SDK <code>Configuration/driverId</code> at SDK initialization time.
/// In addition to predefined special attributes, up to 4 custom key value attributes
/// can be associated with a driver using the Fairmatic SDK.
/// <blockquote>
/// Warning: All attribute keys can be atmost 64 characters in length.
///
/// </blockquote>
/// <blockquote>
/// Warning: All attribute values can be atmost 1024 characters in length.
///
/// </blockquote>
/// <h2>See Also</h2>
/// <ul>
///   <li>
///     <code>DriverAttributes/setCustomAttribute(_:forKey:)</code>
///   </li>
/// </ul>
SWIFT_CLASS_NAMED("DriverAttributes")
@interface FairmaticDriverAttributes : NSObject
/// Creates a <code>DriverAttributes</code> object with the given driver details
/// \param name The name of the driver. This field is REQUIRED and should be a non-empty string.
/// If you pass an empty string, the <code>Fairmatic/setupWith(configuration:delegate:completionHandler:)</code> API will report <code>FairmaticError/invalidDriverName</code> error.
///
/// \param email The email of the driver
///
/// \param phoneNumber The phone number of the driver
///
- (nonnull instancetype)initWithName:(NSString * _Nonnull)name email:(NSString * _Nullable)email phoneNumber:(NSString * _Nullable)phoneNumber OBJC_DESIGNATED_INITIALIZER;
/// Set the custom attribute of the user.
/// Up to 4 custom attributes can be set for a user.
/// A new value for an existing key would be overwritten only if the value length
/// is within 1024 characters, otherwise the original value would be retained.
/// \param key A key for the custom attribute. The maximum key length is 64 characters.
///
/// \param value Value of the custom attribute. The maximum value length is 1024 characters.
///
///
/// returns:
/// <code>true</code>, if the value was set, <code>false</code> otherwise.
- (BOOL)setCustomAttribute:(NSString * _Nonnull)value forKey:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
/// Set the vehicle type for the driver.
/// To enable the feature for any vehicle type other than <code>VehicleType/car</code>,
/// please reach out to your contact at Fairmatic
/// \param vehicleType The <code>VehicleType</code> for the driver.
/// Passing <code>VehicleType/unknown</code> is a no-op.
///
///
/// returns:
/// <code>true</code>, if the value was set, <code>false</code> otherwise.
- (BOOL)setVehicleType:(enum FairmaticVehicleType)vehicleType SWIFT_WARN_UNUSED_RESULT;
/// Returns driver attributes as a json string. Empty string if json serialization
/// fails.
- (NSString * _Nonnull)asJson SWIFT_WARN_UNUSED_RESULT;
/// Returns the driver attributes as a dictionary.
- (NSDictionary * _Nonnull)asDictionary SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// This contains the best estimated results for a drive, this is returned from
/// <code>FairmaticDelegate/processEnd(ofDrive:)</code> callback.
/// The data of this type will always be of same or little bad quality than
/// <code>AnalyzedDriveInfo</code> returned from <code>FairmaticDelegate/processAnalysis(ofDrive:)</code>
/// All drives with driveType not set to <code>DriveType/invalid</code> will get a
/// corresponding <code>FairmaticDelegate/processAnalysis(ofDrive:)</code> callback.
/// Typically <code>FairmaticDelegate/processAnalysis(ofDrive:)</code> will be fired within
/// a few seconds after <code>FairmaticDelegate/processEnd(ofDrive:)</code> callback but in some rare cases
/// this delay can be really large depending on phone network conditions.
SWIFT_CLASS_NAMED("EstimatedDriveInfo")
@interface FairmaticEstimatedDriveInfo : FairmaticDriveInfo
@end

enum FairmaticventType : NSInteger;
enum FairmaticEventSeverity : NSInteger;
enum FairmaticTurnDirection : NSInteger;
@class FairmaticSpeedingData;

/// Represents a driving behavior event like phone use, aggressive acceleration etc.
/// It is part of <code>DriveInfo</code> object of <code>FairmaticDelegate/processEnd(ofDrive:)</code> callback.
SWIFT_CLASS_NAMED("Event")
@interface FairmaticEvent : NSObject
/// Start location of the event.
@property (nonatomic, readonly, strong) FairmaticLocationPoint * _Nonnull startLocation;
/// Stop location of the event.
@property (nonatomic, readonly, strong) FairmaticLocationPoint * _Nonnull stopLocation;
/// Epoch timestamp of the start of the event.
@property (nonatomic, readonly) int64_t startTime;
/// Epoch timestamp of the end of the event
@property (nonatomic, readonly) int64_t endTime;
/// The type of the event.
@property (nonatomic, readonly) enum FairmaticventType eventType;
/// The severity of the event.
@property (nonatomic, readonly) enum FairmaticEventSeverity eventSeverity;
/// Denotes the turn direction of a hard turn whether a left or right turn.
@property (nonatomic, readonly) enum FairmaticTurnDirection turnDirection;
/// Additional data in the <code>eventType</code> is <code>EventType/overSpeeding</code>, will be <code>nil</code> otherwise.
@property (nonatomic, readonly, strong) FairmaticSpeedingData * _Nullable speedingData;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// This is returned in <code>Event/eventSeverity</code>, it represents the severity of event if applicable for that event type.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticEventSeverity, "EventSeverity", open) {
/// Severity not applicable for this event type.
  FairmaticEventSeverityNone = 0,
/// This is a low severity event.
  FairmaticEventSeverityLow = 1,
/// This is a high severity event.
  FairmaticEventSeverityHigh = 2,
};

/// The event type as specified in <code>Event.eventType</code>
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticventType, "EventType", open) {
/// This denotes the aggressive behavior of braking too hard.
  FairmaticventTypeHardBrake = 0,
/// This denotes the aggressive behavior of accelerating too fast.
  FairmaticventTypeAggressiveAcceleration = 1,
/// This denotes the distracting behavior of handling the phone while driving.
  FairmaticventTypePhoneHandling = 2,
/// This denotes the aggressive behavior of speeding more than allowed.
/// You will also receive <code>Event/speedingData</code> in this case.
  FairmaticventTypeOverSpeeding = 3,
/// This denotes a collision as detected by Fairmatic SDK.
/// You will also receive <code>FairmaticDelegate/processAccidentDetected(_:)</code>
/// in realtime for this event.
  FairmaticventTypeAccident = 4,
/// This denotes a hard turn as detected by Fairmatic SDK.
  FairmaticventTypeHardTurn = 5,
/// This denotes the distracting behavior of interacting with the phone screen while driving.
  FairmaticventTypePhoneScreenInteraction = 6,
/// This denotes stop sign violations as detected by Fairmatic SDK.
  FairmaticventTypeStopSignViolation = 7,
/// This denotes the distracting behavior of being in a phone call, hands free.
  FairmaticventTypeHandsFreePhoneCall = 8,
/// This denotes the phone screen is on but user is not actively interacting with the screen.
  FairmaticventTypePassiveDistraction = 9,
};


/// Wrapper for extrapolated details for a drive.
SWIFT_CLASS_NAMED("ExtrapolationDetails")
@interface FairmaticExtrapolationDetails : NSObject
/// The additional distance that might be covered before the drive start is detected.
@property (nonatomic, readonly) double extrapolatedDistance;
/// The estimated start location of the active drive.
@property (nonatomic, readonly, strong) FairmaticLocationPoint * _Nonnull estimatedStartLocation;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@protocol FairmaticDelegate;
@class FairmaticSettings;
enum FairmaticSDKHealthReason : NSInteger;

/// The Fairmatic API. This class contains static methods for all the functionality that the Fairmatic SDK provides.
/// The client code should use this class to interact with the Fairmatic SDK.
/// <blockquote>
/// For all the methods that accept a completion handler as a parameter, please note that the completion handler is always invoked on the main queue by the Fairmatic SDK. If you are performing heavy operations in the body of the completion handler, make sure that you switch to the appropriate queue.
///
/// </blockquote>
/// <blockquote>
/// Warning: Make sure to call the <code>setupWith(configuration:delegate:completionHandler:)</code> method to set the SDK up with calling any other methods.
///
/// </blockquote>
SWIFT_CLASS_NAMED("Fairmatic") SWIFT_AVAILABILITY(ios,introduced=13.0)
@interface Fairmatic : NSObject
/// No initialization needed from the client
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Initializes the Fairmatic SDK to automatically detect driving and collect
/// data. Client code should call this method before anything else in the Fairmatic API.
/// This method requires network connection to validate the sdkKey from the server.
/// Setup fails and returns <code>false</code> if network is not available.
/// This method returns <code>false</code> whenever setup fails and sets up the error with the
/// error code, cause and description.
/// Things to Consider:-
/// <ul>
///   <li>
///     This API should should be called in your <code>AppDelegate</code>’s <code>application(_:didFinishLaunchingWithOptions:)</code> method as early as possible.
///   </li>
///   <li>
///     If <code>Configuration/driverId</code> or <code>Configuration/sdkKey</code> is changed while
///     doing multiple setups, it will be the same as calling <code>Fairmatic/teardown(completionHandler:)</code> followed by calling <code>Fairmatic/setupWith(configuration:delegate:completionHandler:)</code> with the
///     new parameters.
///   </li>
/// </ul>
/// When data collection needs to be stopped call the <code>teardown(completionHandler:)</code> method.
/// This might be done for example when the application’s user has logged out (and possibly a different user might login later).
/// \param configuration The configuration object used to setup the SDK. This
/// object contains your credentials along with
/// additional setup parameters that you can use to provide
/// meta-information about the user or to tune the sdk
/// functionality.
///
/// \param delegate The delegate object on which Fairmatic SDK will issue callbacks for
/// handling various events. Can be <code>nil</code> if you do not want to
/// register for callbacks.
/// The delegate can also be set at a later point using <code>Fairmatic/setDelegate(_:)</code>
/// method.
///
/// \param handler This block is called when fairmatic setup completes.
/// The application is expected to use the success and error
/// params passed to this block to handle failures. The handler
/// would be invoked on the main thread. Can be nil.
///
+ (void)setupWithConfiguration:(FairmaticConfiguration * _Nonnull)configuration delegate:(id <FairmaticDelegate> _Nullable)delegate completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))handler;
/// Set delegate to receive callbacks for various events from Fairmatic SDK.
/// See <code>FairmaticDelegate</code> for further details.
/// Calling this if Fairmatic is not setup is a no-op. See <code>setupWith(configuration:delegate:completionHandler:)</code> for further details.
/// \param delegate The delegate object to give callbacks on.
///
+ (void)setDelegate:(id <FairmaticDelegate> _Nullable)delegate;
/// The drive detection mode controls how Fairmatic SDK detects drives.
/// See <code>DriveDetectionMode</code> for further details.
/// Use this method to get the current <code>DriveDetectionMode</code>.
+ (enum FairmaticDriveDetectionMode)getDriveDetectionMode SWIFT_WARN_UNUSED_RESULT;
/// Change the drive detection mode to control how Fairmatic SDK detects drives.
/// See <code>DriveDetectionMode</code> for further details. This will override the mode sent
/// with <code>Configuration</code> during setup.
/// Calling this method stops an ongoing auto-detected drive.
/// If the SDK is not setup calling this method will result in a no-op.
/// \param driveDetectionMode The new drive detection mode.
///
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// success, A boolean that suggests if drive is started successfully
/// error, A valid <code>FairmaticError</code> is returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError/notSetup</code>
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)setDriveDetectionMode:(enum FairmaticDriveDetectionMode)driveDetectionMode completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Stops driving data collection. The application can disable the Fairmatic SDK
/// by invoking this method. This method is asynchronous.
/// The teardown method is internally synchronized with
/// <code>setupWith(configuration:delegate:completionHandler:)</code> method, and the enclosing application should avoid synchronizing the two methods independently. Calling this
/// with nil completion handler is same as calling teardown method.
/// \param handler Called when method completes. The handler would be invoked on main thread. Can be nil.
///
+ (void)teardownWithCompletionHandler:(void (^ _Nullable)(void))handler;
/// Wipe out all the data that Fairmatic keeps locally on the device.
/// When Fairmatic SDK is torn down, trip data that is locally persisted continues to remain persisted.
/// The data will be uploaded when SDK setup is called at a later time.
/// Wipeout should be used when the application wants to remove all traces of Fairmatic on the device.
/// Data cannot be recovered after this call.
/// <blockquote>
/// This call can only be made when the SDK is not running.
/// Call <code>teardown(completionHandler:)</code> to tear down a live SDK before making this call else <code>FairmaticError/notTornDown</code> will be reported
///
/// </blockquote>
+ (void)wipeOutWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// This API allows application to override Fairmatic’s auto drive detection
/// algorithm.
/// Invoking this method forces the start of a drive. If this API is
/// used then it is application’s responsibility to terminate the drive by
/// invoking <code>stopManualDrive(completionHandler:)</code> method. If an auto-detected drive is in progress, that drive
/// is stopped and a new drive is started.
/// These methods should be used only by applications which have explicit
/// knowledge of start and end of drives and want to attribute drive data to
/// specific trackingIds.
/// Calling it without having initialized the Fairmatic framework
/// <code>setupWith(configuration:delegate:completionHandler:)</code> is a no-op.
/// Calling <code>startManualDrive(trackingId:completionHandler:)</code> with the same trackingId without calling <code>stopManualDrive(completionHandler:)</code> in between
/// is a no-op. Calling <code>startManualDrive(trackingId:completionHandler:)</code> with a different trackingId: with implicitly call <code>stopManualDrive(completionHandler:)</code> before starting a new drive.
/// This is an asynchronous method, <code>FairmaticDelegate/processStart(ofDrive:)</code>
/// is triggered once this finishes with basic information about the drive. <code>activeDriveInfo</code> will return <code>nil</code> until <code>FairmaticDelegate/processStart(ofDrive:)</code> is called
/// You need to call <code>stopManualDrive(completionHandler:)</code> to stop drive data collection.
/// \param trackingId Optional identifier which allows identifying this drive uniquely. If this value is <code>nil</code>, the SDK will supply a default trackingId.
/// It may not be an empty string. It will be truncated to 64 characters if it is longer than 64 characters. Passing invalid <code>trackingId</code> is an error. Please use <code>isValidInputParameter(_:)</code> to validate the trackingId.
///
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// <code>success</code>:  A boolean that suggests if drive is started successfully
/// <code>error</code>: A valid <code>FairmaticError</code> is returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError/notSetup</code>, <code>FairmaticError/invalidTrackingId</code>
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)startManualDriveWithTrackingId:(NSString * _Nullable)trackingId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// This should be called to indicate the end of a drive started by invoking
/// <code>startManualDrive(trackingId:completionHandler:)</code>
/// This block has no return value and two arguments:
/// the error, A valid <code>FairmaticError</code> is returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError/notSetup</code>, <code>FairmaticError/invalidTrackingId</code>,
/// <code>FairmaticError/internalFailure</code>.
/// Refer to <code>FairmaticError</code> for more details on the errors.
/// <ul>
///   <li>
///     <code>success</code> boolean that suggests if drive is stopped successfully
///   </li>
/// </ul>
/// Calling it without having initialized the Fairmatic SDK is a no-op.
+ (void)stopManualDriveWithCompletionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Start a session in the SDK.
/// Applications which want to record several user’s drives as a session may use
/// this call.
/// All drives, either automatically detected or started using <code>startManualDrive(trackingId:completionHandler:)</code>,
/// will be tagged with the sessionId if a session is already in progress. If a drive
/// is already on when this call is made, that drive will not belong to this
/// session.
/// This session id will be made available as a query parameter in the
/// reports and API that Fairmatic provides.
/// The application must call <code>stopSession()</code> when it wants to end the session.
/// Only one session may be active at a time. Calling <code>startSession(_:)</code> when a session is
/// already active with a new <code>sessionId</code> will stop the ongoing session and start a new
/// one.
/// Calling it without having initialized the Fairmatic SDK is a no-op.
/// \param sessionId an identifier that identifies this session uniquely. Cannot
/// be null or an empty string. Cannot be longer than 64 characters.
/// Use <code>isValidInputParameter(_:)</code> to verify that <code>sessionId</code> is valid.
/// Passing invalid string is a no-op.
///
+ (void)startSession:(NSString * _Nonnull)sessionId;
/// Stop currently ongoing session. No-op if no session is ongoing. Trips that
/// start after this call do not belong to the session. Ongoing trips at the time of this
/// call will continue to belong to the session that was just stopped. Also see <code>startSession(_:)</code>
+ (void)stopSession;
/// Use this method to check whether the parameter string passed
/// to the SDK is valid.
/// All strings passed as input params to Fairmatic SDK cannot contain
/// the following characters-
/// “?”, “ “, “&”, “/”, “", “;”, “#”
/// Non-ascii characters are not allowed.
/// \param input The string to validate.
///
///
/// returns:
/// <code>true</code> if the string is <code>nil</code> or valid, <code>false</code> otherwise.
+ (BOOL)isValidInputParameter:(NSString * _Nullable)input SWIFT_WARN_UNUSED_RESULT;
/// Returns an identifier which can be used to identify this SDK build.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull buildVersion;)
+ (NSString * _Nonnull)buildVersion SWIFT_WARN_UNUSED_RESULT;
/// Get info on the currently active drive. If sdk is not setup or if
/// no drive is in progress, nil is returned.
///
/// returns:
/// The currently active drive information.
+ (FairmaticActiveDriveInfo * _Nullable)activeDriveInfo SWIFT_WARN_UNUSED_RESULT;
/// Returns a boolean indicating whether Fairmatic SDK can detect accidents
/// on this devices or not.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL isAccidentDetectionSupportedByDevice;)
+ (BOOL)isAccidentDetectionSupportedByDevice SWIFT_WARN_UNUSED_RESULT;
/// Returns a NSDictionary with keys as <code>EventType</code> and values being Bool which represent
/// if a particular event will be detected by the SDK on this device.
+ (NSDictionary * _Nonnull)getEventSupportForDevice SWIFT_WARN_UNUSED_RESULT;
/// Send a debug report of the current driver to Fairmatic.
/// The Fairmatic SDK will create a background task to ensure the
/// completion of this upload task.
+ (void)uploadAllDebugDataAndLogs;
/// This <code>Settings</code> class surfaces errors in the device or application settings that affect trip detection in the SDK.
/// Your application should check this object to ensure that the SDK is set up correctly and has all the necessary permissions
/// to detect trips accurately.
///
/// returns:
/// A valid <code>Settings</code> object if the SDK is setup, otherwise nil.
+ (FairmaticSettings * _Nullable)getSettings SWIFT_WARN_UNUSED_RESULT;
/// Logs all the critical permissions required by the SDK
/// \param sdkHealthReason indicates the reason for logging SDK Health
///
+ (void)logSDKHealth:(enum FairmaticSDKHealthReason)reason completionHandler:(void (^ _Nonnull)(NSError * _Nullable))completionHandler;
@end


@interface Fairmatic (SWIFT_EXTENSION(FairmaticSDK))
/// Start Fairmatic insurance period 1 in the SDK.
/// A manual trip of a default trackingId will be started immediately on this call.
/// The entire duration in this period will be recorded as a single trip.
/// If period 1 is already in progress with the same trackingId, this call will be a no-op.
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// A boolean that suggests successful completion of the call
/// and a valid <code>FairmaticError</code> is returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError/notSetup</code>, <code>FairmaticError/insurancePeriodSame</code>,
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)startDriveWithPeriod1:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Start Fairmatic insurance period 2 in the SDK.
/// A manual trip of id trackingId will be started immediately on this call.
/// The entire duration in this period will be recorded as a single trip.
/// If period 2 is already in progress with the same trackingId, this call will be a no-op.
/// \param trackingId An identifier which allows identifying this drive uniquely.
/// This drive identifier must be unique for the user.
///
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// A boolean that suggests successful completion of the call
/// and a valid <code>FairmaticError</code> is returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError/notSetup</code>, <code>FairmaticError/insurancePeriodSame</code>,
/// <code>FairmaticError/invalidTrackingId</code>.
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)startDriveWithPeriod2:(NSString * _Nonnull)trackingId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Start Fairmatic insurance period 3 in the SDK.
/// A manual trip of id trackingId will be started immediately on this call.
/// The entire duration in this period will be recorded as a single trip.
/// If period 3 is already in progress with the same trackingId, this call will be a no-op.
/// \param trackingId An identifier which allows identifying this drive uniquely.
/// This drive identifier must be unique for the user.
///
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// A boolean that suggests successful completion of the call
/// and a valid error <code>FairmaticError</code> is returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError/notSetup</code>, <code>FairmaticError/insurancePeriodSame</code>,
/// <code>FairmaticError/invalidTrackingId</code>.
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)startDriveWithPeriod3:(NSString * _Nonnull)trackingId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Stop currently ongoing Fairmatic insurance period if any.
/// Ongoing trips at the time of this call will be stopped.
/// Auto trip detection is turned off on this call.
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// A boolean that suggests successful completion of the call
/// and a valid <code>FairmaticError</code> is returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError/notSetup</code>.
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)stopPeriod:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
@end


/// Delegate for <code>Fairmatic</code>.
/// <h2>See Also</h2>
/// <ul>
///   <li>
///     <code>Fairmatic/setDelegate(_:)</code>
///   </li>
///   <li>
///     <code>Fairmatic/setupWith(configuration:delegate:completionHandler:)</code>
///   </li>
/// </ul>
SWIFT_PROTOCOL_NAMED("FairmaticDelegate") SWIFT_AVAILABILITY(ios,introduced=13.0)
@protocol FairmaticDelegate <NSObject>
@optional
/// Called on delegate in the main thread when <code>Fairmatic</code> SDK detects a potential
/// start of a drive.
/// \param startInfo Info about drive start. Refer to <code>DriveStartInfo</code> for further details.
///
- (void)processStartOfDrive:(FairmaticDriveStartInfo * _Nonnull)startInfo;
/// Called on delegate in the main thread when <code>Fairmatic</code> SDK resumes a
/// drive after a gap.
/// The gap in drive recording may occur due to an application restart by the OS,
/// application kill and restart by a user, an application crash or other reasons.
/// Drives started by calling <code>Fairmatic/startManualDrive(trackingId:completionHandler:)</code> are always resumed and they
/// will not end until <code>Fairmatic/stopManualDrive(completionHandler:)</code> is called.
/// \param resumeInfo Info about drive resume. Refer to <code>DriveResumeInfo</code> for further details.
///
- (void)processResumeOfDrive:(FairmaticDriveResumeInfo * _Nonnull)resumeInfo;
/// Called on the delegate on the main thread when <code>Fairmatic</code> SDK detects a drive to have been completed.
/// It is possible that <code>Fairmatic</code> SDK might decide at a later time that an
/// ongoing trip was a falsely detected trip. In such scenario <code>processEnd(ofDrive:)</code> will be invoked on delegate with <code>DriveInfo/driveType</code> set to <code>DriveType/invalid</code>.
/// Every trip with <code>DriveInfo/driveType</code> not set to <code>DriveType/invalid</code>
/// will receive a corresponding <code>processAnalysis(ofDrive:)</code> callback containing
/// additional info related to this drive.
/// \param estimatedDriveInfo Best estimate info about the drive.
/// Refer to <code>EstimatedDriveInfo</code> for further details.
///
- (void)processEndOfDrive:(FairmaticEstimatedDriveInfo * _Nonnull)estimatedDriveInfo;
/// Called on the delegate in the main thread when <code>Fairmatic</code> SDK finishes
/// full analysis of all valid drives returned from <code>processEnd(ofDrive:)</code> callback.
/// This will be called for all the <code>processEnd(ofDrive:)</code> callbacks
/// with the value of <code>DriveInfo/driveType</code> not set to <code>DriveType/invalid</code>.
/// This may contain additional or improved data over the <code>EstimatedDriveInfo</code>
/// returned from <code>processEnd(ofDrive:)</code>
/// Typically this callback will be fired within a few seconds after <code>processEnd(ofDrive:)</code> callback but in some rare cases this delay can be really large depending on phone network conditions.
/// This callback will be fired in trip occurrence sequence, i.e from oldest trip to
/// the latest trip.
/// \param analyzedDriveInfo Analyzed insights of the drive.
///
- (void)processAnalysisOfDrive:(FairmaticAnalyzedDriveInfo * _Nonnull)analyzedDriveInfo;
/// [Disabled by default]
/// This callback is fired on the main thread when a potential accident is detected by the SDK during a drive.
/// This is a preliminary callback of a potential collision. This collision is confirmed or invalidated by <code>processAccidentDetected(_:)</code> callback.
/// <blockquote>
/// This is disabled by default. To enable, reach out to your contact at Fairmatic
///
/// </blockquote>
/// \param accidentInfo Info about accident.
///
- (void)processPotentialAccidentDetected:(FairmaticAccidentInfo * _Nonnull)accidentInfo;
/// This callback is fired on the main thread when an accident is detected by
/// the SDK during a drive. Any ongoing auto-detected/manual drives will be stopped
/// after this point.
/// \param accidentInfo Info about accident.
///
- (void)processAccidentDetected:(FairmaticAccidentInfo * _Nonnull)accidentInfo;
/// This callback gives information about errors in device or application settings that
/// may be affecting Fairmatic SDK.
/// This callback is fired on the main thread after SDK setup and whenever
/// location permission or <code>Configuration/driveDetectionMode</code> changes,
/// provided the location permission is determined.
/// The recommended flow is to ask for the permissions before SDK is setup
/// because if the location permission is not determined this callback will not be
/// fired.
/// If you receive this callback in the foreground you can show the errors using  any UI
/// constructs like alert controllers, if this callback is received in the background you can
/// use a notification. If you want to add actions to the notification then please don’t
/// rely on errors received at the time of notification as they might have changed by
/// the time the user clicks on the notification. Instead use <code>Fairmatic/getSettings()</code>
/// to get the latest errors and show appropriate message to the user.
/// \param settings A valid <code>Settings</code> object that contains
/// information about errors affecting the Fairmatic SDK.
///
- (void)settingsChanged:(FairmaticSettings * _Nonnull)settings;
@end

/// Error returned as code of <code>NSError</code> from <code>Fairmatic</code> public APIs in case of
/// failures.
/// In case you are using Objective-C, the errors would be returned as <code>NSError</code> objects. In that case, you can use the <code>code</code> of the <code>NSError</code> to get the appropriate <code>FairmaticError</code>
/// \code
/// // Considering that the name of the variable is `nsError`,
/// // you can check the proper error code
/// // using the following format:
/// long code = (long) nsError.code
/// NSString *errorDescription = nsError.localizedDescription
/// NSLog(errorDescription)
///
/// if (errorCode == FairmaticErrorNotSetup) {
///     NSLog(@"Fairmatic SDK is not setup");
/// }
///
/// \endcodeYou can also cast the <code>code</code> of the error to <code>FairmaticError</code> enum to get the enum value like:
/// \code
/// FairmaticError errorCode = (FairmaticError) nsError.code
/// switch (fmError) {
///     case FairmaticErrorNotSetup:
///         NSLog(@"Fairmatic SDK is not setup");
///         break;
///     default:
///         break;
/// }
///
/// \endcode
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticError, "FairmaticError", open) {
/// SDK Key used in setup is invalid
  FairmaticErrorInvalidSDKKeyString = 0,
/// Network not reachable, Fairmatic.setup sometimes needs network call
/// for authentication and to update SDK configuration to work. This error
/// is returned whenever network is not available in these scenarios.
  FairmaticErrorNetworkUnreachable = 1,
/// Fairmatic SDK does not support the OS version of the device.
  FairmaticErrorUnsupportedOSVersion = 2,
/// Fairmatic SDK does not support the device type.
  FairmaticErrorDeviceUnsupported = 3,
/// Invalid parameter was passed to the API.
  FairmaticErrorInvalidParams = 101,
/// Internal error.
  FairmaticErrorInternalFailure = 102,
/// Fairmatic SDK is not setup. This error is also returned in case SDK setup has started but completion handler for setup is not called yet.
  FairmaticErrorNotSetup = 103,
/// Insurance Period hasn’t changed from the previously active period, action ignored.
/// This error may be returned from <code>Fairmatic/startDriveWithPeriod1(_:)</code>, <code>Fairmatic/startDriveWithPeriod2(_:completionHandler:)</code>,
/// <code>Fairmatic/startDriveWithPeriod3(_:completionHandler:)</code>.
  FairmaticErrorInsurancePeriodSame = 104,
/// Invalid <code>trackingId</code> passed for new drive. This error may be returned from
/// <code>Fairmatic/startDriveWithPeriod2(_:completionHandler:)</code>,
/// <code>Fairmatic/startDriveWithPeriod3(_:completionHandler:)</code>.
  FairmaticErrorInvalidTrackingId = 105,
/// Fairmatic SDK is not torn down. This error is returned if the requested operation cannot
/// be completed while the SDK is running like the <code>Fairmatic/wipeOut(completion:)</code> API.
  FairmaticErrorNotTornDown = 106,
/// Some IO error occured while doing the operation. Refer to error description for more info.
  FairmaticErrorIoError = 107,
/// User is not authorized to use this application.
  FairmaticErrorUserDeprovisioned = 111,
/// Operation failed because the set vehicle type feature is disabled in the config.
  FairmaticErrorUnsupportedVehicleType = 112,
/// This error is thrown when the size of the fleet has exceeded the limit. Please get in touch with your contact at Fairmatic to increase the limit.
  FairmaticErrorFleetSizeLimitExceeded = 1002,
/// This error is thrown by the <code>Fairmatic/setupWith(configuration:delegate:completionHandler:)</code> API when the driver associated with the provided <code>Configuration/driverId</code> has been deleted. Please get in touch with your contact at Fairmatic with the <code>driverId</code>.
  FairmaticErrorDriverDeleted = 1003,
/// This error is thrown by the <code>Fairmatic/setupWith(configuration:delegate:completionHandler:)</code> API when you provide the driver name provided in <code>DriverAttributes</code> is invalid. Please use a non-empty string as name when calling <code>DriverAttributes/init(name:email:phoneNumber:)</code>
  FairmaticErrorInvalidDriverName = 1004,
};
static NSString * _Nonnull const FairmaticErrorDomain = @"FairmaticSDK.FairmaticError";

@class FairmaticMockAccidentConfig;

/// This class contains methods that mock Fairmatic’s functionality for testing purposes.
SWIFT_CLASS_NAMED("FairmaticTest") SWIFT_AVAILABILITY(ios,introduced=13.0)
@interface FairmaticTest : NSObject
/// Use this method to test <code>Fairmatic</code> Accident detection integration. Works only in
/// <code>DEBUG</code> mode, disabled in <code>RELEASE</code> mode.
/// On invoking this method, you will get a final accident callback <code>FairmaticDelegate/processAccidentDetected(_:)</code> on your
/// delegate after 5 seconds. You can look at console logs for debugging in case you
/// do not receive the callback. If issue persists, reach out to your contact at Fairmatic.
/// warning:
/// While invoking this method on a simulator, make sure your are simulating
/// location (In Simulator menu bar, select Features->Location->Apple).
/// \param confidence Any value from <code>AccidentConfidence</code> enum.
///
+ (void)raiseMockAccident:(enum FairmaticAccidentConfidence)confidence;
/// Use this method to test <code>Fairmatic</code> Accident detection integration. Works only in <code>DEBUG</code> mode,
/// disabled in <code>RELEASE</code> mode.
/// This API can be used to test multiple callbacks. You need to enable <code>Configuration/implementsMultipleAccidentCallbacks</code>
/// for that.
/// In case of multiple callbacks enabled, on invoking this method, you will get a potential accident callback
/// on your delegate. After <code>MockAccidentConfig/delayBetweenCallbacks</code> seconds, you will
/// get a final accident callback.
/// In case only single callback is enabled by setting <code>Configuration/implementsMultipleAccidentCallbacks</code> as <code>false</code>,
/// on invoking this method, you will get a final accident callback that is <code>FairmaticDelegate/processAccidentDetected(_:)</code>.
/// You can look at console logs for debugging in case you do not receive the callback.
/// If issue persists, reach out to your contact at Fairmatic.
/// warning:
/// While invoking this method on a simulator, make sure your are simulating
/// location (In Simulator menu bar, select Features->Location->Apple).
/// \param config Configuration which determines the <code>AccidentInfo</code> values in the two callbacks.
///
+ (void)raiseMockAccidentUsing:(FairmaticMockAccidentConfig * _Nonnull)config;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class FairmaticScannedBeaconInfo;

/// This class provides helper methods for scaning beacons in the proximity.
SWIFT_CLASS_NAMED("FairmaticVehicleTagging")
@interface FairmaticVehicleTagging : NSObject
/// Get all the beacons which are in the device’s range.
/// Example:
/// \code
/// FairmaticVehicleTagging.getNearbyBeacons(uuid: "FD94C06F-8667-46C2-A334-14C6BF8EDEC3",
///  major: 100,
///  minor: 100,
///  completionHandler: { (beaconsList: [ScannedBeaconInfo], error:  NSError?) -> Void in
///      if let error = error {
///          // handle the error
///      }
///
///     // update scanned beacons list in state or redraw UI
///     })
///
/// \endcode\param uuid The UUID of the beacons that are to be scanned.
///
/// \param major The major of the beacons that are to be scanned.
///
/// \param minor The minor of the beacons that are to be scanned.
///
/// \param completionHandler The completion handler which is to be executed after the completion of beacon scan.
///
+ (void)getNearbyBeaconsWithUuid:(NSString * _Nonnull)uuid major:(int32_t)major minor:(int32_t)minor completionHandler:(void (^ _Nonnull)(NSArray<FairmaticScannedBeaconInfo *> * _Nonnull, NSError * _Nullable))completionHandler;
/// Get all the beacons which are in the device’s range.
/// Example:
/// \code
/// FairmaticVehicleTagging.getNearbyBeacons(uuid: "FD94C06F-8667-46C2-A334-14C6BF8EDEC3",
///  completionHandler: { (beaconsList: [ScannedBeaconInfo], error:  NSError?) -> Void in
///      if let error = error {
///          // handle the error
///      }
///     // update scanned beacons list in state or redraw UI
///     })
///
/// \endcode\param uuid The UUID of the beacons that are to be scanned.
///
/// \param completionHandler The completion handler which is to be executed after the completion of beacon scan.
///
+ (void)getNearbyBeaconsWithUuid:(NSString * _Nonnull)uuid completionHandler:(void (^ _Nonnull)(NSArray<FairmaticScannedBeaconInfo *> * _Nonnull, NSError * _Nullable))completionHandler;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// Error returned as code to <code>NSError</code> from <code>FairmaticVehicleTagging</code> public APIs in case of failures.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticVehicleTaggingError, "FairmaticVehicleTaggingError", open) {
/// Fairmatic SDK is not setup. This error is also returned in case SDK setup has started but completion handler for setup is not called yet.
/// <h2>See Also</h2>
/// <ul>
///   <li>
///     <code>Fairmatic/setupWith(configuration:delegate:completionHandler:)</code>
///   </li>
/// </ul>
  FairmaticVehicleTaggingErrorNotSetup = 0,
/// <code>FairmaticVehicleTagging/getNearbyBeacons(uuid:major:minor:completionHandler:)</code> failed to scan for beacons.
  FairmaticVehicleTaggingErrorBeaconScanTimeout = 6,
/// An unknown error occured in the Vehicle Tagging APIs. Please get in touch your contact at Fairmatic for further assistance.
  FairmaticVehicleTaggingErrorUnknownError = 1000,
};
static NSString * _Nonnull const FairmaticVehicleTaggingErrorDomain = @"FairmaticSDK.FairmaticVehicleTaggingError";

/// The types of insurance period in <code>Fairmatic</code>
/// Each drive belongs to exactly one of these insurance periods.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticInsurancePeriod, "InsurancePeriod", open) {
/// Applications that do not use Insurance APIs will have drives with this value for insurance period
  FairmaticInsurancePeriodNoPeriod = 0,
/// Drives undertaken with insurance period 1 will have this value.
/// Refer: <code>Fairmatic/startDriveWithPeriod1(_:)</code>
  FairmaticInsurancePeriodPeriod1 = 1,
/// Drives undertaken with insurance period 2 will have this value.
/// Refer: <code>Fairmatic/startDriveWithPeriod2(_:completionHandler:)</code>
  FairmaticInsurancePeriodPeriod2 = 2,
/// Drives undertaken with insurance period 3 will have this value.
/// Refer: <code>Fairmatic/startDriveWithPeriod3(_:completionHandler:)</code>
  FairmaticInsurancePeriodPeriod3 = 3,
};


/// Represents a geographical coordinate.
SWIFT_CLASS_NAMED("LocationPoint")
@interface FairmaticLocationPoint : NSObject
/// Epoch timestamp of the location point.
@property (nonatomic, readonly) int64_t timestamp;
/// Latitude in degrees
@property (nonatomic, readonly) double latitude;
/// Longitude in degrees
@property (nonatomic, readonly) double longitude;
/// Compares any object with LocationPoint.
/// \param object an object to be compared with this LocationPoint object.
///
///
/// returns:
/// <code>true</code> if the given object is equal to this LocationPoint object,
/// <code>false</code> otherwise.
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// Returns a dictionary that represents the <code>LocationPoint</code> object.
- (NSDictionary * _Nonnull)toDictionary SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// This class contains parameters required by <code>FairmaticTest/raiseMockAccident(using:)</code> for testing accident flow.
SWIFT_CLASS_NAMED("MockAccidentConfig")
@interface FairmaticMockAccidentConfig : NSObject
/// This field specifies the confidence for the potential accident callback -  <code>FairmaticDelegate/processPotentialAccidentDetected(_:)</code>.
/// Default value is <code>AccidentConfidence/high</code>.
@property (nonatomic) enum FairmaticAccidentConfidence potentialAccidentConfidence;
/// This field specifies the confidence for the final accident callback - <code>FairmaticDelegate/processAccidentDetected(_:)</code>
/// Default value is <code>AccidentConfidence/high</code>.
@property (nonatomic) enum FairmaticAccidentConfidence finalAccidentConfidence;
/// This field specifies the confidence for the potential accident callback - <code>FairmaticDelegate/processPotentialAccidentDetected(_:)</code>.
/// Default value is 70.
@property (nonatomic) NSInteger potentialAccidentConfidenceNumber;
/// This field specifies the confidence number for the final accident callback - - <code>FairmaticDelegate/processAccidentDetected(_:)</code>
/// Default value is 70.
@property (nonatomic) NSInteger finalAccidentConfidenceNumber;
/// This field specifies the callback delay (in seconds) between the potential and final accident callback.
/// Default value is 20 seconds.
@property (nonatomic) NSInteger delayBetweenCallbacks;
/// This field specifies the vehicle type at the time of potential accident callback and final accident callback.
/// Default value is <code>VehicleType/car</code>.
@property (nonatomic) enum FairmaticVehicleType vehicleType;
/// This field specifies the collision severity at the time of potential accident callback and final accident callback.
/// Default value is <code>CollisionSeverity/high</code>.
@property (nonatomic) enum FairmaticCollisionSeverity collisionSeverity;
/// This field specifies the direction of impact at the time of potential accident callback and final accident callback.
/// Default value is <code>DirectionOfImpact/unknown</code>.
@property (nonatomic) enum FairmaticDirectionOfImpact directionOfImpact;
/// Creates a Fairmatic <code>MockAccidentConfig</code> object.
- (nonnull instancetype)init;
/// This method causes the final callback to invalidate the potential callback.
/// Invalidating final callbacks have confidence number as 0 and confidence as <code>AccidentConfidence.invalid</code>,
/// signifying that the accident send out via the potential accident callback on further analysis has been reclassified as <em>not</em> being an accident.
- (void)invalidateFinalCallback;
@end






/// The types of phone positions during a trip.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticPhonePosition, "PhonePosition", open) {
/// The case when <code>Fairmatic</code> was unable to determine the position of the phone during a trip.
  FairmaticPhonePositionUnknown = 0,
/// The case when <code>Fairmatic</code> was able to determine confidently that the phone was on mount during a trip.
  FairmaticPhonePositionMount = 1,
};

/// Dictates the reason for is logging SDK Health
/// The SDK health will be recorded when there is any update in permission from last recorded SDK health.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticSDKHealthReason, "SDKHealthReason", open) {
/// Indicates the reason is unknown.
/// This is the default value.
  FairmaticSDKHealthReasonUnknown = 0,
/// Indicates that the SDK health will be recorded due to silent push notification
  FairmaticSDKHealthReasonSilentPushNotification = 1,
/// Indicates that the SDK health will be recorded due to background processing
  FairmaticSDKHealthReasonBackgroundProcessing = 2,
};


/// Wrapper for beacons scanned using <code>FairmaticVehicleTagging/getNearbyBeacons(uuid:major:minor:completionHandler:)</code>.
SWIFT_CLASS_NAMED("ScannedBeaconInfo")
@interface FairmaticScannedBeaconInfo : NSObject
/// The UUID of the scanned beacon.
@property (nonatomic, readonly, copy) NSString * _Nonnull uuid;
/// The major of the scanned beacon.
@property (nonatomic, readonly) NSInteger major;
/// The minor of the scanned beacon.
@property (nonatomic, readonly) NSInteger minor;
/// The RSSI of the scanned beacon.
@property (nonatomic, readonly) NSInteger rssi;
/// Constants that reflect the relative distance to a beacon.
@property (nonatomic, readonly) CLProximity proximity;
/// The accuracy of the proximity value, measured in meters from the beacon.
@property (nonatomic, readonly) CLLocationAccuracy accuracy;
/// The timestamp representing when the beacon was observed.
@property (nonatomic, readonly) int64_t timestamp;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class FairmaticSettingsError;

/// This class surfaces errors in device or application settings that affects trip detection in the SDK.
SWIFT_CLASS_NAMED("Settings")
@interface FairmaticSettings : NSObject
/// List of errors that must be resolved for trip detection to work correctly.
@property (nonatomic, readonly, copy) NSArray<FairmaticSettingsError *> * _Nonnull errors;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


enum FairmaticSettingsErrorType : NSInteger;

/// This class represent an error in device or application settings that is affecting
/// the ability of the SDK to detect trips.
SWIFT_CLASS_NAMED("SettingsError")
@interface FairmaticSettingsError : NSObject
/// Error type for SettingsError
@property (nonatomic, readonly) enum FairmaticSettingsErrorType errorType;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Error type for <code>SettingsError</code>
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticSettingsErrorType, "SettingsErrorType", open) {
/// The location authorization status is determined but the user hasn’t granted
/// the <em>Always</em> location authorization to the application.
  FairmaticSettingsErrorTypeLocationPermissionNotAuthorized = 0,
/// The activity authorization status is determined but the user has <em>not authorized</em> application to
/// access the motion and fitness data. This error will only be thrown if activity based trip detection
/// is enabled for the application.
/// note:
/// if the current drive detection is <em>not</em> <code>DriveDetectionMode/autoON</code>, this
/// error will not be thrown.
  FairmaticSettingsErrorTypeActivityPermissionNotAuthorized = 1,
/// The location authorization is <em>Always</em> but location accuracy authorization
/// is <em>not</em> <code>CLAccuracyAuthorizationFullAccuracy</code>.
  FairmaticSettingsErrorTypeLocationAccuracyAuthorizationReduced = 2,
/// The location service is turned off.
  FairmaticSettingsErrorTypeLocationServiceOff = 3,
};


/// A valid object of this class is returned in <code>Event/speedingData</code>
/// whenever <code>Event/eventType</code> is equal to <code>EventType/overSpeeding</code>.
SWIFT_CLASS_NAMED("SpeedingData")
@interface FairmaticSpeedingData : NSObject
/// The speed limit in meters per second.
@property (nonatomic, readonly) double speedLimitMPS;
/// The average speed of the user during this speeding event duration in meters per second.
@property (nonatomic, readonly) double userSpeedMPS;
/// Maximum speed of the user during this speeding event duration in meters per second.
@property (nonatomic, readonly) double maxUserSpeedMPS;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


enum FairmaticTripWarningType : NSInteger;

/// Represents a single warning that might have occurred during your trip.
/// A collection of these warnings are provided using the
/// <code>FairmaticDelegate/processAnalysis(ofDrive:)</code> callback.
SWIFT_CLASS_NAMED("TripWarning")
@interface FairmaticTripWarning : NSObject
/// The type of the trip warning.
@property (nonatomic, readonly) enum FairmaticTripWarningType tripWarningType;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The value return from <code>TripWarning/tripWarningType</code>.
/// Enum representing warnings detected for the current drive.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticTripWarningType, "TripWarningType", open) {
/// The trip duration is unexpectedly large and signifies a possible integration issue.
  FairmaticTripWarningTypeUnexpectedTripDuration = 0,
};

/// This is returned in <code>Event/turnDirection</code>, it represents the turn direction for <code>EventType/hardTurn</code>
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticTurnDirection, "TurnDirection", open) {
/// This is returned for all <code>Event/eventType</code> values other than <code>EventType/hardTurn</code>
  FairmaticTurnDirectionNotAvailable = 0,
/// Indicates that the turn direction of the event was left.
  FairmaticTurnDirectionLeft = 1,
/// Indicates that the turn direction of the event was right.
  FairmaticTurnDirectionRight = 2,
};

/// The value return from <code>DriveInfo/userMode</code>. Indicates whether user
/// was a driver or passenger.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticUserMode, "UserMode", open) {
/// Indicates that the user was in the driver seat.
/// All values in <code>DriveInfo</code> will be set.
  FairmaticUserModeDriver = 0,
/// Indicates that the user was in the passenger seat.
  FairmaticUserModePassenger = 1,
/// Indicates that either <code>DriveInfo/driveType</code> is not
/// <code>DriveType/drive</code> or <code>Fairmatic</code> was not able to determine user mode.
/// All values in <code>DriveInfo</code> will be set.
  FairmaticUserModeUnavailable = 2,
};

/// Type of vehicle used in the drive recorded by the Fairmatic SDK.
/// A default vehicle type can be set using <code>DriverAttributes/setVehicleType(_:)</code>
/// in <code>DriverAttributes</code>. The detected type is returned to the application in the <code>DriveInfo/vehicleType</code>
/// field of the <code>FairmaticDelegate/processAnalysis(ofDrive:)</code> callback.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticVehicleType, "VehicleType", open) {
/// Indicates a car vehicle type.
  FairmaticVehicleTypeCar = 0,
/// Indicates a motorcycle vehicle type.
  FairmaticVehicleTypeMotorcycle = 1,
/// Indicates that the user was not driving.
  FairmaticVehicleTypeUnknown = -1,
};







#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
